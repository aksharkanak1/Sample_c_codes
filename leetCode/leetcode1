https://leetcode.com/problems/maximum-number-of-balloons/
class Solution(object):
    def maxNumberOfBalloons(self, text):
        """
        :type text: str
        :rtype: int
        """
        
        map1={}
        count=0;
        str1="balloon"
        nomorepossible=0
        for i in text :
            try :
                map1[i]+=1
            except :
                map1[i]=1
                
        for i in str1 :
            if i not in map1.keys():
                return count 
                
        while True :
            for i in str1:
                if map1[i] > 0 :
                   map1[i]-=1
                else :
                   nomorepossible=1 
                   break  
            if 0 == nomorepossible :
                count+=1
            else :
                break 
        return count        
            
        
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

#include "limits.h"

void  update_max_array(int *prices , int *max , int pricesSize)
{
    int i =0;
    int max1 =INT_MIN ;
    
    for (i=pricesSize-1; i>=0 ;i--)
    {
        if(prices[i] > max1)
        { 
            max1=prices[i];
            max[i]=max1;
        }    
        else 
        {
            max[i]=max1;
        }    
    }    
}

int maxProfit(int* prices, int pricesSize)
{
    int *max= NULL ;
    int max2=INT_MIN;
    int i=0;
    max=malloc(sizeof(int) *pricesSize );
    if(NULL == max)
    {
        return 0;
    }    
    memset(max,0,sizeof(int) *pricesSize);
    
    update_max_array(prices,max,pricesSize);
    
    for(i=0;i<pricesSize;i++)
    {
        if((max[i] -prices[i]) > max2)
           max2= max[i] -prices[i];    
    }    
    return max2;
}
https://leetcode.com/problems/reverse-linked-list
void reverseList2(struct ListNode* head,struct ListNode** ahead , struct ListNode**rhead)
{
    
    if(NULL != head && NULL == head->next)
    {
        *ahead=head;
        *rhead=head;
        return  ;
    }    
    
    reverseList2(head->next,ahead,rhead);
    (*rhead)->next=head;
    *rhead=head;
}    

struct ListNode* reverseList(struct ListNode* head)
{
    struct ListNode*h= NULL ;
    struct ListNode*t= NULL ;
    if(NULL == head || NULL == head->next)
        return head;
    reverseList2(head,&h,&t);
    t->next=NULL ;
    return h ;
}
https://leetcode.com/problems/binary-tree-level-order-traversal/
class Solution:
    def levelOrder2(self, root,lst,level):
        if None == root :
           return 
        try :
            lst[level].append(root.val)
        except :    
            lst2=[]
            lst2.append(root.val)
            lst.append(lst2)
        
        self.levelOrder2(root.left,lst,level+1)
        self.levelOrder2(root.right,lst,level+1)
    
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        retLst=[]
        self.levelOrder2(root,retLst,0)
        return retLst
https://leetcode.com/problems/sort-array-by-increasing-frequency
class Solution(object):
    def cmp(self,x,y):
        if x[0] == y[0] :
           if x[1] == y [1] :
              return 0
           elif x[1] > y [1] :
              return  -1
           else:
              return 1
        else:
           if x[0] == y[0] :
              return  0
           elif x[0] <y[0] :
              return -1 
           else:
              return 0
    
    def frequencySort(self, nums):
        
        map1={}
        lst=[]
        lst2=[]
        
        for i in nums :
            try :
                map1[i]=(map1[i][0]+1,i)
            except :
                map1[i]=(1,i)
                
        for i in map1.keys():
             lst.append(map1[i])
                
        lst.sort(cmp=self.cmp)
        
        for i in lst:
              lst3=i[0]*[i[1]]
              lst2.extend(lst3)
        
        return lst2
            
                
https://leetcode.com/problems/sort-characters-by-frequency
class Solution:
    def frequencySort(self, s: str) -> str:
        map1={}
        lst=[]
        finalStr=""
        
        for i in s :
            try :
                map1[i]=(map1[i][0]+1,i)
            except :
                map1[i]=(1,i)
        for j in map1.keys():
            lst.append(map1[j])
                
        lst.sort(reverse=True)
        
        for i in lst:
             tempstr=i[1]*i[0]
             finalStr=finalStr+tempstr
                
        return finalStr       
                
        
https://leetcode.com/problems/valid-palindrome/
#include <string.h>
char Tolow(char c)
{
    char t =0;
    int dis =0;
    if(c <='z' && c>= 'a')
        return c;
     
     dis =c-'A';
     return ('a'+dis);
}    

int isalpha1 (char c)
{
    if((c >='A' && c<= 'Z') || ((c>='a') && (c<='z'))||
       ((c >= '0') &&(c<='9')))
       {
           return 1 ;
       }   
       return 0;
}    


bool isPalindrome(char * s)
{
    char * p = NULL ;
    char * q = NULL ;
    bool ret = true;
    p = s ;
    q=strlen(s)-1+s;
    if(p ==q)
       return  ret ; 
    
    while (p < q)
    {
        if (!isalpha1(*p))
        {
            p++;
            continue ;
        }    
        if (!isalpha1(*q))
        {
            q--;
            continue; 
        }     
        if(Tolow(*p) != Tolow(*q))
        {
            ret=false;
            break;
        }    
        else 
        {
            p++;
            q--;
        }    
        
    }    
    
    return (ret);

}

https://leetcode.com/problems/range-sum-of-bst

int rangeSumBST2(struct TreeNode* root, int low, int high, int *sum){
    
    if(NULL == root)
        return 0;

    if(((root->val)<=high) &&((root->val)>=low))
        *sum=(*sum)+root->val ;
    
    rangeSumBST2(root->left,low,high,sum);
    rangeSumBST2(root->right,low,high,sum);
    
    return 0;

}

int rangeSumBST(struct TreeNode* root, int low, int high){
    int sum =0;
    
    rangeSumBST2(root,low,high,&sum);
    return  sum;    
}
https://leetcode.com/problems/second-minimum-node-in-a-binary-tree
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def findSecondMinimumValue2(self, root, minV , data):
        if(None == root):
            return 
        
        if minV != root.val :
           if -1 == data[0]:
               data[0]=root.val 
           elif root.val < data[0]:
              data[0]=root.val  
           
        self.findSecondMinimumValue2(root.left,minV,data)
        self.findSecondMinimumValue2(root.right, minV,data)
    
    def findSecondMinimumValue(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        data=[-1]
        self.findSecondMinimumValue2(root,root.val,data) 
        return  data[0]
https://leetcode.com/problems/kth-smallest-element-in-a-bst/
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    
    def kthSmallest2(self, root, k,data,cnt):
        if  None == root or None != data[0] or (k) < cnt[0] :
            return  
        
        
        
        self.kthSmallest2(root.left,k,data,cnt)
        cnt[0]=cnt[0]+1
        if k == cnt[0]:
            data[0] = root.val
        self.kthSmallest2(root.right,k,data,cnt)

        
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        data=[None]
        cnt=[0]
        self.kthSmallest2(root,k,data,cnt)
        return data[0]
https://leetcode.com/problems/delete-node-in-a-bst
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

struct TreeNode *get_lowest_element_from_tree(struct TreeNode *root)
{
    struct TreeNode *temp = NULL ;
    struct TreeNode *temp1 = NULL ;
    
    if(NULL == root)
        return root ;
    
    if(NULL == root->left)
        return root ; 
    
    temp=root->left ;
    temp1=temp;
    while(NULL != temp)
    {
        temp1=temp ;
        temp = temp->left; 
    }
    return temp1 ;
}    

struct TreeNode *get_higest_element_from_tree(struct TreeNode *root)
{
    struct TreeNode *temp = NULL ;
    struct TreeNode *temp1 = NULL ;
    
    if(NULL == root)
        return root ;
    
    if(NULL == root->right)
        return root ;
    
    temp=root->right ;
    temp1=temp;
    while(NULL != temp)
    {   
        temp1=temp;
        temp = temp->right;
    }
    return temp1 ;
}  

struct TreeNode* deleteNode(struct TreeNode* root, int key)
{
    struct TreeNode* temp = NULL ;
    
    int tempVal= 0;
    if(NULL == root)
        return  NULL ;
    
    if(key == root->val)
    {
         if(NULL == root->left && NULL == root->right )
         {
             free(root);
             return  NULL ;
         } 
        
         temp =  get_lowest_element_from_tree(root->right);
         if(NULL != temp)
         {
             root->val=temp->val ;
             root->right=deleteNode(root->right,temp->val);
             return root ;
         }    
        
        temp = get_higest_element_from_tree(root->left) ;
        root->val=temp->val ;
        root->left=deleteNode(root->left,temp->val);
        return  root ;
      }    
    else if (key > root->val )
    {
        root->right=deleteNode(root->right,key);
    }    
    else 
    {
        root->left=deleteNode(root->left, key);
    }    
    return root ;
}
https://leetcode.com/problems/insert-into-a-binary-search-tree
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def insertIntoBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        if None ==  root :
           temp =  TreeNode(val)
           return temp 
        
        if val > root.val :
           root.right=self.insertIntoBST(root.right,val)
        if val < root.val :
           root.left=self.insertIntoBST(root.left,val)
        
        return root 

https://leetcode.com/problems/search-in-a-binary-search-tree
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


void searchBST2(struct TreeNode* root, int val,struct TreeNode** out )
{
    if (NULL != *out || NULL == root)
        return  ;
    
    if (val == root->val )
    {
        *out=root;
        return  ;
    } 
    else if (val > (root->val) )
    {
        searchBST2(root->right,val,out);
    }    
    else 
    {
        searchBST2(root->left,val,out);
    }    
}
    
struct TreeNode* searchBST(struct TreeNode* root, int val)
{
   struct TreeNode* temp = NULL ;
    
   searchBST2(root,val,&temp);
    
   return temp ;
}

https://leetcode.com/problems/delete-leaves-with-a-given-value
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def removeLeafNodes2(self, root, target):
        
        if None == root :
           return None 
    
        if None == root.left and None == root.right and target == root.val:
           del root
           return None 
    
    
        root.left=self.removeLeafNodes2(root.left, target)
        root.right=self.removeLeafNodes2(root.right, target)
        
        if None == root.left and None == root.right  and target == root.val :
           del root
           return None  
        
        return root 
    
    def removeLeafNodes(self, root, target):
        """
        :type root: TreeNode
        :type target: int
        :rtype: TreeNode
        """
        temp = self.removeLeafNodes2(root,target)
        return temp
               
https://leetcode.com/problems/symmetric-tree
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSymmetric2(self, root1, root2,status):
        if status[0] == 0:
           return 
    
        if None == root1 and None == root2 :
           return 
    
        if (None != root1 and None == root2) or (None == root1 and None != root2) or (root1.val != root2.val) :
           status[0]=0
           return 
       
        self.isSymmetric2(root1.left,root2.right,status)
        self.isSymmetric2(root1.right, root2.left,status)
        
        return
    
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        status=[]
        status.append(1)
        self.isSymmetric2(root.left, root.right, status)
        if status[0] == 1 :
           return  True 
        else :
           return False     
	   	   
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    
    
    def get_path(self, root, p , path1):
        if None ==  root or (len(path1) > 0 and p == path1[-1]):
           return 
        
        path1.append(root)
        self.get_path(root.left,p,path1)
        self.get_path(root.right,p,path1)
        if p != path1[-1] :
           del path1[-1]
        
    def print_path(self,path):
        print("print path ")
        for i in path :
            print(str(i.val)+" ")
    
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        pathp=[]
        pathq=[]
        idx=-1
        self.get_path(root,p,pathp)
        self.get_path(root,q,pathq)
        self.print_path(pathp)
        self.print_path(pathq)
        if len(pathp) >len(pathq):
           length=len(pathq)
        else: 
           length=len(pathp)
        
        for i in range(length):
            if pathp[i] == pathq[i]:
               continue 
            else:
               idx=i-1
               break 
                 
        if len(pathp) >len(pathq):           
           return pathq[idx] 
        else: 
           return pathp[idx] 
        
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

struct TreeNode* lowestCommonAncestor2(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q, struct TreeNode **res) {
    
    if(NULL == root || NULL != *res)
        return NULL ;
    
    if(root == p )
    {
        *res=p;
        return NULL ;
    }    
    
    if(root == q)
    {
        *res=q;
        return NULL ;
    }     
    
    if((root->val > p->val ) && (root->val > q->val ))
    {
        lowestCommonAncestor2(root->left,p,q,res);
    }    
    else if ((root->val < p->val ) && (root->val < q->val ))
    {
        lowestCommonAncestor2(root->right,p,q,res);
    }    
    else if(((root->val > p->val ) && (root->val < q->val ))||((root->val < p->val ) && (root->val > q->val )))
    {
        *res=root;
        return NULL ;
    }    
    
    return  NULL ;
}

struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    struct TreeNode* temp = NULL ;
    
    lowestCommonAncestor2(root,p,q,&temp);
    
    return temp; 
    
}


https://leetcode.com/problems/invert-binary-tree
struct TreeNode* invertTree(struct TreeNode* root)
{
     struct TreeNode * t = NULL ;
     if(NULL == root)
         return NULL ;
    
    invertTree(root->left);
    invertTree(root->right);
    
    t=root->left ;
    root->left=root->right ;
    root->right=t ;
    return root ;
}

Merge trees 
https://leetcode.com/problems/merge-two-binary-trees/
struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2)
{
    struct TreeNode* ret= NULL;    
    
    if(NULL == root1 && NULL == root2)
        return NULL ;
    
    ret=( struct TreeNode *)malloc(sizeof(struct TreeNode));
    memset(ret,0,sizeof(struct TreeNode));
    if(NULL == ret)
          return NULL ;
    ret->val=((NULL != root1)?root1->val:0)+((NULL != root2)?root2->val:0);
    ret->left=mergeTrees((NULL !=root1)?root1->left:NULL ,(NULL !=root2)?root2->left:NULL);
    ret->right=mergeTrees((NULL !=root1)?root1->right:NULL ,(NULL !=root2)?root2->right:NULL);
    return ret; 
}


https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/

void sum1(struct TreeNode* root , unsigned long long * ret , unsigned long long* sum  )
{
    if(NULL ==  root)
        return ;
    
    if(1==(root->val))
    {
        *ret=((*ret<<1) | 0x01);
    }    
    else 
    {
         *ret=(*ret<<1);
    }    
    if((NULL == (root->left)) && (NULL == (root->right)))
    {
        *sum=*sum+*ret;
    }    
    sum1(root->left,ret,sum);
    sum1(root->right,ret,sum);
    
    *ret=(*ret>>1);
}    

int sumRootToLeaf(struct TreeNode* root)
{
      unsigned long long ret =0;
      unsigned long long sum=0;
        
      sum1(root,&ret,&sum);
    
       return sum;

}

https://leetcode.com/problems/sum-root-to-leaf-numbers/submissions/
void sum1(struct TreeNode* root , unsigned long long * ret , unsigned long long *sum)
{
    if(NULL == root)
        return ;
    
    *ret=(*ret)*10+root->val;
    
    if((NULL == (root->left)) && (NULL == (root->right)))
    {
        *sum=(*sum)+(*ret);
    }    
    sum1(root->left,ret,sum);
    sum1(root->right,ret,sum);
    *ret=(*ret/10);
}  

int sumNumbers(struct TreeNode* root)
{
     unsigned long long ret=0;
     unsigned long long sum=0;
      sum1(root,&ret,&sum);
    
      return sum;

}

https://leetcode.com/problems/validate-binary-search-tree/

#include <limits.h>
void isValidBST2(struct TreeNode* root,long long  max , long long min,int *invalid)
{
    if(1==*invalid || NULL == root )
        return ;
    
    isValidBST2(root->left,((long long)(root->val))-1,min,invalid);
    #if 0
    if(!((max>(root->val)) &&((root->val)>min)))
    {
        *invalid=1;
    }
    #endif 
    if((root->val) > max || ((root->val)<min))
    {
        *invalid=1;
    }    
    isValidBST2(root->right,max,((long long )(root->val))+1,invalid);
        
}  

bool isValidBST(struct TreeNode* root){

     int invalid=0;
    
     if(NULL == root )
         return false ;
    
     if(NULL == root->left && NULL == root->right )
         return true ;
    
    
     isValidBST2(root,INT_MAX,INT_MIN,&invalid);
    
    
    if(1==invalid)
        return false;
    else 
        return true;

}

https://leetcode.com/problems/balanced-binary-tree/
int isBalanced2(struct TreeNode* root, int *nob)
{
    int lh=0;
    int rh=0;

    if(NULL == root )
        return 0;

    lh=isBalanced2(root->left, nob);
    rh=isBalanced2(root->right, nob);
    
    printf("\nrh=%d lh=%d\n",rh,lh);
    
    if((rh > lh) && ((rh-lh) >1) )
       *nob=1;
    else if ((rh < lh) && ((lh-rh) >1))
        *nob=1;
    if((rh > lh))
        return  (rh+1);
    else 
        return (lh+1);
}


bool isBalanced(struct TreeNode* root)
{
      int x=0;
       
      isBalanced2(root,&x);
    
       if(1==x)
          return false ;
       else
          return true ;   
}

https://leetcode.com/problems/binary-tree-pruning

struct TreeNode* pruneTree(struct TreeNode* root)
{
    if(NULL == root)
        return NULL;
    
    root->left=pruneTree(root->left);
    root->right=pruneTree(root->right);
    
    if(NULL == root->left && NULL == root->right)
    {
        if(0 == (root->val))
        {
            free(root);
            return NULL ;
        }    
    } 
    
    return root ;

}
https://leetcode.com/problems/rotate-array
void rotate(int* nums, int numsSize, int k){
   int i =0;
   //int temp=0;
    int *data= NULL ;
    int temp = numsSize;
    int *temp2= NULL ;
    
   if((k==numsSize && numsSize%k == 0) || (0 == numsSize) || (0 ==k))
       return ;
    
    data=malloc(sizeof(int)*numsSize*2);
    memset(data,0,sizeof(int)*numsSize*2);
    
    if(k > numsSize)
        k=k%numsSize ;
    
    memcpy(data,nums,sizeof(int)*numsSize);
    memcpy(((char*)data)+(sizeof(int)*numsSize),nums,sizeof(int)*numsSize);
    temp2=&data[numsSize];
    temp2=temp2-k;
    memcpy(nums,temp2,sizeof(int)*numsSize);
    
}

https://leetcode.com/problems/cousins-in-binary-tree
void aresiblings(struct TreeNode* root , int x, int y, int*areSib)
{
    if(NULL == root || 1 == *areSib)
        return ;
    
    if((NULL !=(root->left)) && (NULL != (root->right)))
    {
        if(((x==(root->left->val)) && (y == (root->right->val)))||
            ((y==(root->left->val)) && (x == (root->right->val))))
            {
                *areSib=1;
                return; 
            }    
    }   
    if(NULL != (root->left)) 
       aresiblings(root->left,x,y,areSib);  
    if (NULL != (root->right))
       aresiblings(root->right,x,y,areSib);    
              
}    

void getLevel(struct TreeNode* root , int x, int *xlevel, int level)
{
    if(NULL ==  root)
        return;
    
    if(*xlevel >=0)
        return;
    if(x == root->val)
    {
        *xlevel=level;
        return  ;
    }    
    getLevel(root->left,x,xlevel,level+1);
    getLevel(root->right,x,xlevel,level+1);
    
}            
            
            

bool isCousins(struct TreeNode* root, int x, int y)
{
    int areSib=0;
    int levelx=-1;
    int levely=-1;
    aresiblings(root,x,y,&areSib);
    
    if(1 == areSib)
        return  false ;
    
    getLevel(root,x,&levelx,0);
    getLevel(root,y,&levely,0);
    
    if((-1 != levelx) &&(-1 !=levely) && (levelx == levely))
    {
        return true;
    }    
    else 
        return  false;
    

}

https://leetcode.com/problems/add-binary
#define MAX_SIZE 10025

void revStr(char * str, int i , int j)
{
    char temp =0;
    while(i<=j)
    {
        temp=str[i];
        str[i]=str[j];
        str[j]=temp;
        i++;
        j--;
    }    
}    

char * addBinary(char * a, char * b)
{
     char *ret = NULL ;
     int la=0;
     int lb=0;
     int c=0; 
     int retIdx=0; 
     int sum =0;
     int i=0,j=0;
    
      ret=(char *) malloc(sizeof(char) *MAX_SIZE);
     
      if(NULL == ret)
          return ret ;
    
      memset(ret,0,sizeof(char) *MAX_SIZE);
    
      la=strlen(a);
      lb=strlen(b);
      i=la-1;
      j=lb-1;
      while((i>=0) || (j>=0))
      {   
          sum=0;
          if(i>=0)
          {
              sum+=(a[i]-'0')+c;
              c=0;
          }    
          if(j>=0)
          {
              sum+=(b[j]-'0')+c;
              c=0;
          }    
          c=sum/2;
          sum=sum%2;
          printf("\n%d\n",sum);
          ret[retIdx]='0'+sum;
          retIdx++;
          i--;
          j--;
      }
      if(1 ==c )
      {
          ret[retIdx]='0'+1;
      }    
      else 
          retIdx--;
      
      printf("\n%s\n",ret);
      revStr(ret,0,retIdx);
    
      return ret;
}


https://leetcode.com/problems/linked-list-in-binary-tree
/*
Create recursive function, given a pointer in a Linked List and any node in the Binary Tree. Check if all the elements in the linked list starting from the head correspond to some downward path in the binary tree.
*/
void check_for_list(struct ListNode* node , struct TreeNode* root, int *got_list)
{
    if(1 == *got_list || NULL == node || NULL == root)
        return ;
    
    if((NULL == node->next) && ( node->val == root->val))
    {
        *got_list=1;
    }    
    
    if(node->val  == root->val)
    {
        check_for_list(node->next,root->left,got_list);
        check_for_list(node->next,root->right,got_list);
    }    
    else 
        return  ;
}

void traverse(struct ListNode* head, struct TreeNode* root , int *got_list)
{
    if(NULL == head || NULL == root || 1 == *got_list)
     return ;
    
    if(head->val == root->val)
      check_for_list(head,root,got_list);
    
    traverse(head,root->left,got_list);
    traverse(head,root->right,got_list);
}


bool isSubPath(struct ListNode* head, struct TreeNode* root)
{
     int got_list=0;
    
      traverse(head,root,&got_list);
    
       if(1 == got_list)
           return true ;
        else 
           return false ; 

}

https://leetcode.com/problems/design-linked-list
typedef struct node_s
{
    int val ;
    struct node_s *next ;
}node_t;


typedef struct {
    int c;
    node_t *head;
    node_t *tail ;
} MyLinkedList;

/** Initialize your data structure here. */

MyLinkedList* myLinkedListCreate() {
    
   MyLinkedList* temp = NULL ;
    
    temp=malloc(sizeof(MyLinkedList));
    if(NULL == temp)
       return NULL ;
    
    memset(temp,0,sizeof(MyLinkedList));
    return  temp;
    
}

/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
int myLinkedListGet(MyLinkedList* obj, int index) {
    node_t * t=0;
    int i =0;
    
    if(NULL == obj)
        return -1;
    
    if(index >=obj->c)
        return -1;
    
    t=obj->head;
    
    for(i=0;i<(obj->c);i++)
    {
        if(i == index)
           return t->val; 
        
        t=t->next ;
    }    
    
    return -1;
  
}

/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
void myLinkedListAddAtHead(MyLinkedList* obj, int val)
{
    node_t* t=0;
    
    if(NULL == obj)
        return ;
    
    t=malloc(sizeof(node_t));
    if(NULL == t)
        return  ;
    memset(t,0,sizeof(node_t));
    t->val=val;
    
    if(0 == obj->c)
    {
        obj->head=obj->tail=t;
        obj->c=1;
    }    
    else 
    {
        t->next=obj->head;
        obj->head=t;
        (obj->c)++;
    }    
  
}

/** Append a node of value val to the last element of the linked list. */
void myLinkedListAddAtTail(MyLinkedList* obj, int val) {
        node_t * t=0;
    
    if(NULL == obj)
        return ;
    
    t=malloc(sizeof(node_t));
    if(NULL == t)
        return  ;
    memset(t,0,sizeof(node_t));
    t->val=val;
    
    if(0 == obj->c)
    {
        obj->head=obj->tail=t;
        obj->c=1;
    }    
    else 
    {
        obj->tail->next=t;
        obj->tail=t;
        (obj->c)++;
    }   
  
}

/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
void myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {
    
    node_t * t =NULL ;
     node_t * t1 =NULL ;
    int jumps=index-1;
    node_t * temp = NULL ;
    int i=0;
    
    if(NULL ==  obj)
        return ;
    
    if (index > (obj->c))
        return ;
    
    t=malloc(sizeof(node_t));
    if(NULL == t)
        return  ;
    memset(t,0,sizeof(node_t));
    t->val=val;
    
    if(0 == index)
    {
        t->next=obj->head;
        obj->head=t;
        if(obj->tail == NULL )
            obj->tail=obj->head;
        (obj->c)++;
    }
    else if (index == (obj->c))
    {
        obj->tail->next = t;
        obj->tail=t;
        (obj->c)++;
    }    
    else 
    {   temp=obj->head;
        for(i=0;i<jumps;i++)
        {
             temp=temp->next ;
        }    
        t->next=temp->next ;
        temp->next=t;
        (obj->c)++;    
    }    
    
  
}

/** Delete the index-th node in the linked list, if the index is valid. */
void myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) 
{
    node_t * t = NULL;
    node_t *t1=NULL  ; 
    int jumps=0 , i=0;
    if(NULL == obj )
        return ;
    
    if((0 == obj->c) || (index >((obj->c)-1)))
        return;
    
    if( 0 == index)
    {
        t=obj->head;
        obj->head=t->next ;
        free(t);
        (obj->c)--;
    }    
    else 
    {
        t=obj->head;
        jumps =index-1;
        for(i=0;i<jumps;i++)
        {
            t=t->next;
        }    
        t1=t->next ;
        t->next=t1->next ;
        printf("\n------->t1 = %d\n", t1->val);
        if((obj->tail) == t1)
        {
            if(NULL != t1->next)
                obj->tail = t1->next ;
            else 
                obj->tail = t;
                
        }
        free(t1);
        (obj->c)--;
            
    }    
  
}

void myLinkedListFree(MyLinkedList* obj) {
    
    node_t * t1= NULL ;
    node_t *t2= NULL ;
    if(NULL == obj)
        return ;
    int i=0;
    
    if(0 == obj->c)
        return  ;
    
    t1=obj->head;
    t2=t1->next;
    while(NULL != t1)
    {
        free(t1);
        t1=t2;
        if(NULL !=t2)
          t2=t2->next;
    }    
    
    free(obj);
    
}

https://leetcode.com/problems/valid-parentheses
bool isValid(char * s)
{
      int len  = 0;
     char * st=NULL ;
     int i=0;
     int stidx=0;
     len=strlen(s);
     int insert=0;
    
     if(1==len)
         return  false ;
    
     st=(char *) malloc(len);
     if(NULL == st)
        return false ;
     memset(st,0,len);

     st[stidx]=s[0];
    
     for (i=1;i<len;i++)
     {
         insert =1;
        if( -1 < stidx)
        {    
            if((s[i] == ')' && st[stidx] == '(') || (s[i] =='}' && st[stidx] == '{') || (s[i] == ']' && st[stidx] == '['))
            {
                 st[stidx]='\0';
                 stidx--;
                  insert=0;
            } 
         }
         if(1 == insert)
         {
             if(-1==stidx)
             {
                 stidx=0;
                 st[stidx]=s[i];
             }
             else
             {
                 stidx++;
                 st[stidx]=s[i];
             }
            //printf("\n%s\n",st);
         }
     }

     free(st);
     if(-1==stidx)
         return  true ;
      else
         return false;

     

}

https://leetcode.com/problems/climbing-stairs
//check the results for n=1,2,3,4, 5 we can see that its a fibonacci series 
int climbStairs(int n)
{
    int * t = NULL ;
    int i=0;
    
    t= malloc(sizeof(int) *(n+1));
    
    if(NULL == t)
        return 0 ;
    
    memset(t,0,sizeof(int) *(n+1));
    t[0]=1;
    t[1]=1;
    for(i=2;i<=n;i++)
    {
        t[i]=t[i-1]+t[i-2];
    }    
    
    return t[n];
    
}

https://leetcode.com/problems/partition-list
struct ListNode* partition(struct ListNode* head, int x)
{
    struct ListNode* ret= NULL ;
    struct ListNode* t= NULL ;
    struct ListNode* newL = NULL ;
    struct ListNode* newLp= NULL ;
    struct ListNode* newH= NULL ;
    struct ListNode* newHp= NULL ;
    
    if(NULL == head|| NULL == head->next)
        return  head ;
    
    t=head;
    while(NULL != t)
    {
        if(x > t->val)
        {
            
            if(NULL == newL )
            {
                newL=t;
                newLp=newL;
            }    
            else 
            {
                newLp->next=t;
                newLp=t;
            }    
            t=t->next;
            newLp->next= NULL ;
        }    
        else 
        {
          
            if(NULL == newH )
            {
                newH=t;
                newHp=newH;
            }    
            else 
            {
                newHp->next=t;
                newHp=t;
            }    
            t=t->next;
            newHp->next= NULL ;          
        }    
    }
    
    if(NULL !=newLp)
    {    
       newLp->next=newH;
       return newL;
    }
    else 
    {
        return  newH;
    }    
 

}

https://leetcode.com/problems/sort-an-array
void merge(int *nums , int i , int m , int j)
{
    int p=m+1;
    int temp =0;

    while (i<=m && p <= j)
    {
        if(nums[i] >nums[p])
        {
            temp=nums[p];
            memmove((char *)(&nums[i+1]),(char *)(&nums[i]),sizeof(int)*(m-i+1));
            nums[i]=temp;
            p=p+1;
            m=m+1;
            i=i+1;
        }
        else
        {
            i=i+1 ;
        }
    }
}

void merge_without_memmove(int *nums , int i , int m , int j )
{
    int * tempA= NULL ;
    int p=m+1;
    int idx=0;
    int tempi=i;
    int tempj=j;


    tempA=(int *)malloc(sizeof(int) * (j-i+1));
    memset(tempA,0,sizeof(int) * (j-i+1));

    while (i<=m && p<=j)
    {
        if(nums[i] > nums[p])
        {
           tempA[idx]=nums[p];
           p++;
           idx++;
        }
        else
        {
           tempA[idx]=nums[i];
           i++;
           idx++;
        }
    }

    if(i <= m )
    {
      memcpy(&tempA[idx],&nums[i],sizeof(int) * (m-i+1));
    }
    else
    {
      memcpy(&tempA[idx],&nums[p],sizeof(int) * (j-p+1));
    }

    memcpy(&nums[tempi],tempA,sizeof(int)*(tempj-tempi+1));
    free(tempA);
}


void mergeSort(int *nums , int i , int m , int j)
{
    if(i == j)
        return  ;
    mergeSort(nums,i,(m+i)/2,m);
    mergeSort(nums,m+1,((m+1+j)/2),j);
    merge_without_memmove(nums,i,m,j);
}

void printarray(int *a , int len )
{
     int i=0;

     for (i=0;i<len;i++)
     {
          if (i==0 || i %16 ==0)
              printf("\n");
          printf(" %d", a[i]);
     }
}


int* sortArray(int* nums, int numsSize, int* returnSize)
{
     mergeSort(nums,0,(numsSize-1)/2,numsSize-1);
     *returnSize=numsSize;
     printarray(nums,numsSize)    ;
     return nums;
}

https://leetcode.com/problems/binary-search
int search(int* nums, int numsSize, int target)
{
       int i=0;
       int j =0;
       int m =0;
       int ret=-1;
    
       i =0;
       j=numsSize-1;
       
       m=(i+j)/2 ;
    
       while (i <= j)
       {
           if(target < nums[m])
           {
               j=m-1;
               m=(i+j)/2;
           }    
           if(target > nums[m])
           {
               i=m+1;
               m=(i+j)/2;
           }    
           if( target == nums[m])
           {
               ret=m;
               break ;
           }    
       }
      return ret ;
}
https://leetcode.com/problems/first-bad-version
int firstBadVersion(int n) {
    
    unsigned long long  i=1; 
    unsigned long long  j=n;
    unsigned long long m=(i+n)/2;
    bool ret=0;
    int l_ver=0;
    
    while(i <= j)
    {
        printf("\n%d\n", m);
        ret=isBadVersion(m);
        if(true == ret )
        {
            l_ver = m ;
            j=m-1;
            m=(i+j)/2;
        }    
        else
        {
            i=m+1;
            m=(i+j)/2;
        }     
    }  
    
    return  l_ver;
    
}

https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array
int* searchRange(int* nums, int numsSize, int target, int* returnSize)
{
    
    int* pret= NULL ;
    int i=0;
    int j=0;
    int m=0;
    int found =0;
    int temp=0;
    
    
    
    pret=malloc(sizeof(int)*2);
    if(NULL == pret)
        return NULL ;
    
    memset(pret,0,sizeof(int)*2);
    pret[0]=-1;
    pret[1]=-1;
    *returnSize=2 ;
    
    if(0 == numsSize)
        return pret;
    j=numsSize-1;
    m=(i+j)/2;
    while(i<=j)
    {
       if(target <nums[m])
       {
           j=m-1;
           m=(i+j)/2;
       }    
        else if(target > nums[m])
        {
            i=m+1;
            m=(i+j)/2;
        }    
        else if (target == nums[m]) 
        {
            found =1;
            break ;
        }    
    }
    printf("\n%$d\n", found);
    if(1 == found )
    {
        temp=m;
        while((temp >= 0) && (nums[temp] == target))
        {
            temp--;
        }    
        pret[0]=temp+1;
        temp=m;
        while((temp <= (numsSize-1)) && (nums[temp] == target))
        {
            temp++;
        } 
        pret[1]=temp-1; 
    }    
    

    return pret;
}

https://leetcode.com/problems/find-minimum-in-rotated-sorted-array


int findMin(int* nums, int numsSize)
{
    
    int i =0;
    int temp =0;
    
    int j=numsSize-1;
    int m =(i+j)/2;
    
    if(1 == numsSize)
        return nums[0];
    
    if((nums[i] < nums[m]) && (nums[j] > nums[m]))
       return nums[i];
    
    while(i <= j)
    {
        if(j == (i+1))
        {
           if (nums[i] < nums[j])
               return nums[i];
           else 
               return nums[j];
        }        
        if(nums[m] < nums [i])
        {
            j=m;
            m=(i+j)/2;
        } 
        else if (nums[m] > nums [j])
        {
            i=m ;
            m=(i+j)/2;
        }     
    }    
    
    return 0;
}
https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii
int map[200]={0,} ;
        
void update_map(struct ListNode* head)
{
    struct ListNode* t =  head ;
    memset(map,0,sizeof(int)*200);
    
    if(NULL == t )
        return ;
    
    while(NULL != t)
    {
        if(-100 <= (t->val) && 100>=(t->val))
        {    
            map[(t->val)+100]++;
            printf("\nval %d map %d\n",t->val,map[(t->val)+100]);
        }
        t=t->next ;
    }    
}        


struct ListNode* deleteDuplicates(struct ListNode* head)
{
      struct ListNode* p = NULL ;
      struct ListNode* q= NULL;
      struct ListNode* r= NULL ;
      struct ListNode*t= NULL ; 
 
      update_map(head); 
    
      t=head;
      while(NULL != t && map[(t->val)+100] != 1)
      {
          if(map[(t->val)+100] > 1)
          {
              printf("\nfreeing %d  map value %d  is ",t->val,map[(t->val)+100]); 
              r=t->next;
              free(t);
              t=r;
          }    
      }    
    
      head=t;
    
      if(NULL == head || NULL ==  head->next)
          return  head ;
      
       p=head;
       q=head->next ;
       while(NULL != q)
       {
           if(map[(q->val)+100] >1)
           {
               r=q->next;
               free(q);
               p->next=r;
               q=p->next;
           }    
           else
           {
               p=q;
               q=q->next;
           }    
           
       }
    
       return head ;
}

https://leetcode.com/problems/missing-number
int missingNumber(int* nums, int numsSize){
    
    int actual_sum=0;
    int actual_sum_2=0;
    
    int i=0;
    
    for (i=0;i<(numsSize+1);i++)
    {
        actual_sum+=i;
    }    

    for (i=0;i<(numsSize);i++)
    {
        actual_sum_2+=nums[i];
    }      
    
    return (actual_sum-actual_sum_2);
    
}

https://leetcode.com/problems/merge-sorted-array
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n)
{
   int i =  0;
   int j = 0;
   int ri=0;  
   int *ret= NULL ; 

    if(0==m)
    {
        memcpy(nums1,nums2,sizeof(int)*n);
        return ;
    }    
    
    ret=malloc((m+n)*sizeof(int));
    if(NULL == ret )
    {
        return ;  
    }    
    memset(ret,0,(m+n)*sizeof(int));
    
    while(i<m && j<n)
    {
        if(nums1[i] < nums2[j])
        {
            ret[ri]=nums1[i];
            i++;
            ri++;
        }
        else 
        {
            ret[ri]=nums2[j];
            j++;
            ri++;
        }    
    }    
    
    if(i<m)
    {
        while(i<m)
        {
            ret[ri]=nums1[i];
            ri++;
            i++;
        }    
    }
    else 
    {
        while(j<n)
        {
            ret[ri]=nums2[j];
            ri++;
            j++;
        }          
    }    
        
    memcpy(nums1, ret,(m+n)*sizeof(int));
    free(ret);
    return ;

}

https://leetcode.com/problems/squares-of-a-sorted-array
https://www.youtube.com/watch?v=4eWKHLSRHPY
int* sortedSquares(int* nums, int numsSize, int* returnSize){
    
    int * ret = NULL ;
    int s=0;
    int e=numsSize-1;
    int c=numsSize-1;
    int se=0;
    int ss=0;
    
    ret=(int *) malloc(sizeof(int) * numsSize);
    if(NULL == ret)
    {
        return NULL;
    }    
    memset(ret,0,sizeof(int) * numsSize);
    *returnSize=numsSize;
    
    while (s<=e)
    {
        ss=nums[s]*nums[s];
        se=nums[e]*nums[e];
        
        if(ss > se )
        {
            ret[c]=ss;
            c--;
            s++;
        }
        else 
        {
           ret[c]=se;
           c--; 
           e--; 
        }    
    }    
    
    return ret ;
}

https://leetcode.com/problems/contains-duplicate
#define HAX_TABLE_SiZE  1000

typedef struct node_s
{
    int d ;
    struct node_s *n ; 
}node_t;

typedef struct hTable_s
{
    struct node_s **node ;
    int c ;
}hTable_t;

int hash_value(int d)
{
    int ret = d%HAX_TABLE_SiZE ;
    
    if(ret < 0)
       ret= -1 * ret; 
    return (ret);
}

int hash_table_init(hTable_t *ht)
{
    ht->node=(struct node_s **)malloc(sizeof(struct node_s *)*HAX_TABLE_SiZE);
    if(NULL ==  ht->node)
    {
        return -1 ;
    }    
    memset(ht->node,0,sizeof(struct node_s *)*HAX_TABLE_SiZE);
    ht->c=0;
    return 0;
} 

node_t * hash_table_lookup(hTable_t *ht , int d )
{
    int hv = hash_value(d);
    node_t * sn= NULL ;
    
    sn=ht->node[hv];
    
    while (NULL != sn)
    {
        if(sn->d == d)
          return sn ;  
        
        sn=sn->n;
    }
    
    return NULL ;
    
}  

int insert_in_hash_table(hTable_t *h , int d)
{
    int hv=0;
    node_t *t= NULL ;
    node_t *t2= NULL ;
    
    hv=hash_value(d) ;
    
    t=h->node[hv] ;
    if(NULL == t )
    {
        t2=(node_t *)malloc(sizeof(node_t));
        if(NULL ==  t2)
        {
            return  -1;
        } 
        memset(t2,0,sizeof(node_t));
        t2->d=d;
        h->node[hv]=t2 ;   
         (h->c)++;
    } 
    else 
    {
        t2=(node_t *)malloc(sizeof(node_t));
        if(NULL ==  t2)
        {
            return  -1;
        } 
        memset(t2,0,sizeof(node_t));
        t2->d=d;
        t2->n=h->node[hv];
        h->node[hv]=t2;
        (h->c)++;
    } 
    return 0;
}


void delete_hash_table(hTable_t *h)
{
    int i =0;
    node_t *t= NULL ;
    node_t *t2= NULL ;
    
    for (i=0;i<HAX_TABLE_SiZE;i++)
    {
        t=h->node[i];
        while(NULL != t)
        {
            t2=t->n ;
            free(t);
            t=t2;
        }
        h->node[i]=NULL;
    }    
    
    free(h->node);
} 



bool containsDuplicate(int* nums, int numsSize)
{
    hTable_t h ={0,};
    bool ret2=false;
    int ret=-1;
    node_t *t= NULL ;
    int i=0;
    
    
    ret=hash_table_init(&h);
    
    if(-1==ret)
       return  ret2;
    
    hash_table_init(&h);
    
    for (i=0;i<numsSize;i++)
    {
        t=hash_table_lookup(&h,nums[i]);
        if(NULL != t)
        {
            delete_hash_table(&h);
            return true;
        } 
        else 
        {
            insert_in_hash_table(&h,nums[i]);
        }    
    } 
    delete_hash_table(&h);
    return false ;
    
}

https://leetcode.com/problems/contains-duplicate-ii
#define HAX_TABLE_SiZE  1000

typedef struct node_s
{
    int d ;
    int idx;
    struct node_s *n ; 
}node_t;

typedef struct hTable_s
{
    struct node_s **node ;
    int c ;
}hTable_t;

int hash_value(int d)
{
    int ret = d%HAX_TABLE_SiZE ;
    
    if(ret < 0)
       ret= -1 * ret; 
    return (ret);
}

int hash_table_init(hTable_t *ht)
{
    ht->node=(struct node_s **)malloc(sizeof(struct node_s *)*HAX_TABLE_SiZE);
    if(NULL ==  ht->node)
    {
        return -1 ;
    }    
    memset(ht->node,0,sizeof(struct node_s *)*HAX_TABLE_SiZE);
    ht->c=0;
    return 0;
} 

void  hash_table_lookup(hTable_t *ht , int d , node_t ** out , int *len )
{
    int hv = hash_value(d);
    node_t * sn= NULL ;
    
    sn=ht->node[hv];
    
    while (NULL != sn)
    {
        if(sn->d == d)
        {
            out[*len]=sn;
            (*len)++;
        }
        
        sn=sn->n;
    }
    
    return ;
    
}  

int insert_in_hash_table(hTable_t *h , int d, int idx)
{
    int hv=0;
    node_t *t= NULL ;
    node_t *t2= NULL ;
    
    hv=hash_value(d) ;
    
    t=h->node[hv] ;
    if(NULL == t )
    {
        t2=(node_t *)malloc(sizeof(node_t));
        if(NULL ==  t2)
        {
            return  -1;
        } 
        memset(t2,0,sizeof(node_t));
        t2->d=d;
        t2->idx=idx;
        h->node[hv]=t2 ;   
         (h->c)++;
    } 
    else 
    {
        t2=(node_t *)malloc(sizeof(node_t));
        if(NULL ==  t2)
        {
            return  -1;
        } 
        memset(t2,0,sizeof(node_t));
        t2->d=d;
        t2->idx=idx; 
        t2->n=h->node[hv];
        h->node[hv]=t2;
        (h->c)++;
    } 
    return 0;
}


void delete_hash_table(hTable_t *h)
{
    int i =0;
    node_t *t= NULL ;
    node_t *t2= NULL ;
    
    for (i=0;i<HAX_TABLE_SiZE;i++)
    {
        t=h->node[i];
        while(NULL != t)
        {
            t2=t->n ;
            free(t);
            t=t2;
        }
        h->node[i]=NULL;
    }    
    
    free(h->node);
} 




bool containsNearbyDuplicate(int* nums, int numsSize, int k)
{
     int i =0; 
     hTable_t h ={0,};
     node_t *t= NULL ;
     node_t *elm[100000]={0,};
     int len =0; 
     int j=0; 
    
     hash_table_init(&h); 
    
     for(i=0;i<numsSize;i++)
     {
         hash_table_lookup(&h,nums[i],elm,&len);
         if(0 == len )
         {
             insert_in_hash_table(&h,nums[i],i);
         }    
         else 
         {
             for(j=0;j<len;j++)
             {     
                if(abs(i-(elm[j]->idx)) <= k)
                   return true ;
             }    
             insert_in_hash_table(&h,nums[i],i);
         }    
     }    
     delete_hash_table(&h);
     return false ;

}

https://leetcode.com/problems/merge-intervals
#sort the list and we can get the solutions 
class Solution(object):
    def merge(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        """
        l=[]
        s=0
        e=0
        res=[]
        intervals.sort()
        s=intervals[0][0]
        e=intervals[0][1]
        reload1=0;
        for i in intervals[1:] :
            if 1 == reload1:
               s=i[0]
               e=i[1]
               reload1=0;
               continue  
            if e < i[0]:
                res.append([s,e])
                s=i[0]
                e=i[1]
            elif e >= i[0] and e < i[1] :
                e=i[1]
            elif e > i[0] and e > i[1] :
                 continue 
                
        res.append([s,e])         
        return res 
https://leetcode.com/problems/lru-cache/        
class Lst:
      def __init__(self):
          self.f=None
          self.l=None
      
      def insert_at_starting(self,node1):
          temp2=self.f          
          node1.p=None   
          if None != temp2:
             temp2.p=node1
             self.f=node1
             node1.n=temp2
          else : 
             self.f=self.l=node1
             node1.n=node1.p=None    
          
       
      def remove_node(self,node1):
           if None == node1 or ( None == self.f and None == self.l ) :
               return 
            
           temp1=node1.p
           temp2=node1.n
           if None ==  temp1 and None == temp2 :
              self.f=self.l=None 
           elif None ==temp1:
              self.f=temp2
              temp2.p=None              
           elif None == temp2 :
              self.l=temp1
              temp1.n=None                 
           else :
              temp1.n=temp2
              temp2.p=temp1 
           node1.n=node1.p=None 
           return
		   
      def get_last_node(self):
           return self.l 
               
                
            

class Node :
    def __init__(self,data):
        self.data=data
        self.n=None
        self.p=None




class LRUCache(object):

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.map1={}
        self.Lst=Lst() 
        self.c=capacity
        

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        try :
            ret=self.map1[key][0]
        except :
            return -1
        
        self.Lst.remove_node(self.map1[key][1])
        self.Lst.insert_at_starting(self.map1[key][1])
        return ret
                
        
    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: None
        """

        try :
            self.map1[key]=(value,self.map1[key][1])
            self.Lst.remove_node(self.map1[key][1])
            self.Lst.insert_at_starting(self.map1[key][1])           
        except:
            if len(self.map1) >= self.c:
               lastNode1=self.Lst.get_last_node()
               self.Lst.remove_node(lastNode1)
               del self.map1[lastNode1.data]
               del lastNode1 
            newNode=Node(key)
            self.Lst.insert_at_starting(newNode)
            self.map1[key]=(value,newNode)
        #print("map is %s\n" % str(self.map1))    


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)

https://leetcode.com/problems/design-browser-history
class BrowserHistory(object):

    def __init__(self, homepage):
        """
        :type homepage: str
        """
        self.curr=0
        self.lst=[]
        self.lst.append(homepage)
        

    def visit(self, url):
        """
        :type url: str
        :rtype: None
        """
        del self.lst[self.curr+1:]
        self.lst.append(url)
        self.curr=self.curr+1
        

    def back(self, steps):
        """
        :type steps: int
        :rtype: str
        """
        if (self.curr-steps) < 0 :
            self.curr=0
        else :
            self.curr=self.curr-steps 
            
        return self.lst[self.curr]    
        

    def forward(self, steps):
        """
        :type steps: int
        :rtype: str
        """
        retval =""
        try :
            idx=self.curr+steps 
            retval=self.lst[idx]
            self.curr=idx
        except:
            idx=len(self.lst)-1;
            retval=self.lst[idx]
            self.curr=idx
        return retval     

# Your BrowserHistory object will be instantiated and called as such:
# obj = BrowserHistory(homepage)
# obj.visit(url)
# param_2 = obj.back(steps)
# param_3 = obj.forward(steps) 

https://leetcode.com/problems/sort-characters-by-frequency
class Solution(object):
    def frequencySort(self, s):
        """
        :type s: str
        :rtype: str
        """
        m1={}
        idx=0
        for i in s :
            try :
                m1[i][0]=m1[i][0]+1
            except:
                m1[i]=[1,idx,i]
            idx=idx+1
        lst=[]
        for i in m1.keys():
            lst.append(m1[i])
        lst.sort(reverse=True)
        retstr=""
        for i in lst:
            tmpStr=i[2]*i[0]
            retstr=retstr+tmpStr
            
        return retstr    
		
https://leetcode.com/problems/first-unique-character-in-a-string/

typedef struct entry_s
{
    int c;
    int idx; 
}entry_t;

void update_map(entry_t * map , char * s)
{
    int c1=0; 
    while('\0' != *s)
    {
        (map[*s].c)++;
        if(-1 == map[*s].idx)
            map[*s].idx=c1;
        c1++;
        s++;
    }    
}    

int firstUniqChar(char * s){

    entry_t tm[126]={0,};
    int i =0;
    int tmpIdx=-1;
    int tmpc=0;
    
    for (i=0;i<126;i++)
    {
        tm[i].idx=-1;
    }    
    
    update_map(tm,s);
    for(i=0;i<126;i++)
    {
        if (-1 == tmpIdx && tm[i].c == 1)
        {
            tmpIdx=tm[i].idx;
            tmpc=tm[i].c ;
        }
        else if (tm[i].c == 1)
        {
            if(tm[i].idx < tmpIdx)
            {
                tmpIdx=tm[i].idx;
            }    
        }            
    }    
    return tmpIdx;                
}
https://leetcode.com/problems/search-in-rotated-sorted-array-i


int search2(int *nums, int i , int j , int target )
{
    int m =0;
    
    m=(i+j)/2;
    
    while(i <= j)
    {
        if(target>nums[m])
        {
            i=m+1;
            m=(i+j)/2;
        }
        else if (target < nums[m])
        {
            j=m-1;
            m=(i+j)/2;
        }    
        else if(target == nums[m])
        {
            return m ;
        }    
    }    
    return -1;
} 


bool search(int* nums, int numsSize, int target)
{
    
    int * nums1 = NULL ;
    int i =0;
    int p = 0;
    int q=0;
    int temp=0;
    
    
    nums1=malloc(sizeof(int) *numsSize*2);
    if(NULL ==nums1)
        return -1;
    
    memset(nums1, 0,sizeof(int) *numsSize*2);
    
    memcpy(nums1,nums,sizeof(int)*numsSize);
    memcpy(nums1+numsSize,nums,sizeof(int)*numsSize);
    
    temp=nums[0];
    for(i=1;i<numsSize;i++)
    {
        if(temp > nums[i])
        {    
            p=i;
            break;
        }
        temp=nums[i];                
    } 
    
    q=p+numsSize-1;
    
    temp=search2(nums1,p,q,target);
    
    free(nums1);
    if (-1 != temp)
        return true ;
    else 
        return false ;

}
https://leetcode.com/problems/3sum
class Solution(object):
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        ret=[]
        if None == nums or len(nums) < 3 :
           return ret   
        nums.sort()
        idxL=len(nums)-1
        
        for i in range(len(nums)-3+1):
            j=i+1
            k=idxL
            diff=0-nums[i]
            while j < k :
                 if (nums[j]+nums[k]) > diff :
                    k=k-1
                 elif (nums[j]+nums[k]) < diff :
                    j=j+1
                 else :
                    if [nums[i],nums[j],nums[k]] not in ret :
                       ret.append([nums[i],nums[j],nums[k]])
                    j=j+1
                    k=k-1
        return ret

https://leetcode.com/problems/merge-strings-alternately/
char * mergeAlternately(char * word1, char * word2)
{
      char * ret= NULL ;
      int l1=0;
      int l2=0;
      int l3=0;
      int l4=0;
      int i=0;
      int j=0;
    
      if(NULL == word1 && NULL == word2)
      {
          ret=malloc(1);
          if(NULL == ret )
              return  ret ;
          ret[0]='\0' ;
          return ret;
      }    
      l1=strlen(word1);
      l2=strlen(word2);
    
      l3=l1+l2 ;
    

      ret=malloc(l3+1);
      if(NULL == ret)
         return ret;
    
      memset(ret,0,l3+1);
    
      if(0==l1 && 0 == l2)
      {
          ret[0]='\0';
          return ret;
      }    
    
      l4=l1>l2 ?l2:l1;
      while(i<l4)
      {
          ret[j]=word1[i];
          j++;
          ret[j]=word2[i];
          j++;
          i++;
      }    
      
      printf("\n%s",ret);
      if (l1 > l2)
          memcpy(&ret[j],&word1[i],strlen(&word1[i]));
      else if (l1 < l2)
          memcpy(&ret[j],&word2[i],strlen(&word2[i]));
      else 
          ret[j]='\0';
      
       return ret;

}

https://leetcode.com/problems/split-a-string-in-balanced-strings/
int balancedStringSplit(char * s)
{
      int c=0;
      int c1=0;
      int i=0;
      int len=0;
      char *p= s ;
      char *q = s;
    
      p=q=s;  
      while('\0' != *q)
      {
          if(*q=='R')
              c1=c1+1;
           else 
              c1=c1-1;  

          if(0 == c1)
          {
              c++; 
              p=q+1;
              q=p;              
          }
          else 
          {
              q=q+1;
          }    
          
      }    
      return c;

}

https://leetcode.com/problems/count-the-number-of-consistent-strings
#define MAX_SIZE 126
void update_map(char *in, char *map)
{
    int i =0;
    while('\0' != in[i])
    {
        if(0 == map[in[i]])
          map[in[i]]=1;
        i++;
    }    
} 

int countConsistentStrings(char * allowed, char ** words, int wordsSize)
{
    char map[MAX_SIZE]={0,};
    int i=0;
    char *temp=NULL ;
    int c=0;
    
    update_map(allowed, map);
    for(i=0;i<wordsSize;i++)
    {
        temp=words[i];
        if('\0' == *temp)
            continue;
        while('\0' != *temp)
        {
            if(0 == map[*temp])
                break;
            temp=temp+1;
        }    
        if('\0' == *temp)
            c++;
    }    

    return c; 
}

https://leetcode.com/problems/simplify-path

#define PATH_ENTRY_MAX_NUM 3000
#define PATH_LENGTH 3000

typedef struct stack 
{
    int c ;
    char *path_entry[PATH_ENTRY_MAX_NUM];
} stack ;

stack * init_stack()
{
    stack * temp = NULL ;
    
    temp = malloc(sizeof(stack));
    if(NULL == temp)
        return NULL ;
    memset(temp, 0, sizeof(stack));
    temp->c=-1;
    return temp;
}

void free_stack(stack *in)
{
    free(in);
}
           
void push_in_stack(stack *in , char *p)
{
    (in->c)++;
    in->path_entry[in->c]=p;
}
         
char * pop_from_stack(stack *in)
{
    char * ret= NULL ;
    if (0 > (in->c))
       return NULL ;
    
    ret=in->path_entry[in->c];
    (in->c)--;
    return ret;
}           
           
char * peep_from_stack(stack * in)           
{
    char * ret= NULL ;
    if (0 > (in->c))
       return NULL ;
    
    ret=in->path_entry[in->c];
    return ret;
}           

char * simplifyPath(char * path)
{
    stack  * s = NULL ;
    char * p = NULL ;
    char * q= NULL ;
    char end_reached=0;
    char *out = NULL ;
    int i=0;
    
    out=malloc(PATH_LENGTH);
    if(NULL == out)
        return out ;
    
    memset(out,0,PATH_LENGTH);
    
    s=init_stack();
    if(NULL == s)
        return NULL ;
    p=q=path;
    p++;
    q++;
    
    while('\0' != *q)
    {
        while('\0' != *p && '/' == *p)
        {
            p++;
        }
        if('\0' == *p)
           break ;
        q=p+1;
        while('\0' != *q && '/' !=*q)
        {
            q++;
        }
        if('\0' == *q)
        {    
            end_reached=1;
        }  
        *q='\0';
        if(strcmp(p,".")==0)
        {
            p=q+1;
            q=q+1;
        } 
        else if (strcmp("..",p)==0)
        {
            pop_from_stack(s);
            p=q+1;
            q=q+1;
        }
        else
        {    
           push_in_stack(s,p);
           p=q+1;
           q=q+1;
        }    
        if(end_reached)
            break ;
    }    
   
    out[0]='/';
    for (i=0;i<=(s->c);i++)
    {
        printf("\n%p",s->path_entry[i]);
        strcat(out,s->path_entry[i]);
        if(i != s->c)
           strcat(out,"/"); 
    }     
    
    free_stack(s); 
    return out ;     
}


https://leetcode.com/problems/counting-bits
class Solution(object):
    
    def count_1(self,inp):
        mask=1
        v=inp
        cnt=0
        while v > 0 :
              if ( v & mask ) == 1 :
                 cnt=cnt+1
              v=v>>1
        return cnt    
                   
                
    
    def countBits(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        lst=[0]
        for i in range(1,n+1):
            lst.append(self.count_1(i))
        return lst    
       
https://leetcode.com/problems/linked-list-components/
void update_map(char *in, int * a, int an)
{
    int i=0;
    
    for (i=0;i<an;i++)
    {
        in[a[i]]=1;
    }    
}   

#define MAP_SIZE  10005

int numComponents(struct ListNode* head, int* nums, int numsSize)
{
    int nc=0;
    int ret=0;
    char map[MAP_SIZE]={0,};
    
    struct ListNode *temp = NULL ;
    
    if(NULL == head)
        return 0;
    
    temp=head;
    update_map(map,nums,numsSize);
    while(NULL != temp )
    {
        if(1 == map[temp->val])
            nc++;
        else 
        {
            if (nc > 0)
            {
                ret++;
            }    
            nc=0; 
        }    
        temp=temp->next;
    }    
    if(nc>0)
       ret++; 
    return ret;
} 

//https://leetcode.com/problems/lfu-cache
#include "stdio.h"
#include <stdlib.h>
#include <string.h>
typedef struct node_s
{
   struct node_s *n;
   struct node_s *p;
}node_t ;

typedef struct Lst_s
{
   node_t * f;
   node_t * l ;
   int c ;
}Lst;
typedef struct fq_node_s
{
   node_t n;
   Lst lst ;
   int fq ;
}fq_node_t ;

typedef struct anode_s
{
    node_t h;
    node_t l;
    fq_node_t* fql;
    int key ;
    int data ;
    int fq;
}anode_t ;


#define DEBUG 1 



#define HASH_BUCKET_SIZE  100

typedef struct LFUCache
{
  int c;
  int count;
  Lst *ht;
  Lst fqL;
} LFUCache;

node_t * remove_and_return_first_node(Lst*l);
void insert_at_start_list(Lst * l , node_t * node);
void insert_at_end_list(Lst *l , node_t *node );
void remove_node_from_lst(Lst * l , node_t * node);
int  put_new_node_in_fq_list(LFUCache*cache, anode_t * node )
{
    Lst * temp = NULL ;
    fq_node_t * tempfqNode= NULL ;
    if(NULL == cache || NULL == node )
       return -1;

    node->fq=1;
    node->l.n=node->l.p=NULL ;
    temp=&(cache->fqL);
    if(0 == temp->c )
    {
        tempfqNode=(fq_node_t *)malloc(sizeof(fq_node_t ));
        if(NULL == tempfqNode )
        {
           return  -1 ;
        }
        memset(tempfqNode,0,sizeof(fq_node_t ));
        insert_at_start_list(temp,(node_t*)tempfqNode);
        tempfqNode->fq=1;
    }
    else
    {
        tempfqNode=(fq_node_t *)(cache->fqL.f);
    }
    insert_at_end_list(&(tempfqNode->lst),(node_t*)&(node->l));
    node->fql=tempfqNode;
    return 0;
}

void increase_fq_of_node(LFUCache*cache, anode_t * node )
{
    fq_node_t * fq_node= NULL ;
    fq_node_t * nfq_node=NULL ;
    node_t *temp= NULL ;
    int nfq=0;
    if(NULL == cache || NULL == node )
       return ;

    fq_node=node->fql;
    nfq=(node->fq)+1;

    nfq_node=(fq_node_t *)fq_node->n.n ;
    if(NULL == nfq_node )
    {
        nfq_node=(fq_node_t *) malloc(sizeof(fq_node_t ));
        if(NULL == nfq_node )
        {
            return  ;
        }
        memset(nfq_node,0,sizeof(fq_node_t ));
        insert_at_end_list(&(cache->fqL),(node_t*)&(nfq_node->n));
        nfq_node->fq=nfq;
    }
    remove_node_from_lst(&(node->fql->lst),(node_t*)&(node->l));
    insert_at_end_list(&(nfq_node->lst),(node_t*)&(node->l));
    node->fq=nfq;
    node->fql=nfq_node;
}

anode_t * remove_and_return_the_least_frequently_used_node(LFUCache*cache)
{
     node_t * temp ;
     Lst * tempfq= NULL ;
     fq_node_t*temp2= NULL ;  
     if(NULL == cache || 0 == cache->fqL.c )
        return NULL ;
     temp2=(fq_node_t*)(cache->fqL.f);
     if(NULL == temp2)
	return  NULL ;     
     while(NULL!= temp2 && 0 == temp2->lst.c )
     {
         temp2=(fq_node_t*)(temp2->n.n);	     
     }	     
     if(NULL == temp2)
       return NULL;
     temp=remove_and_return_first_node(&(temp2->lst));
     if(NULL ==  temp)
        return NULL ;
     temp=temp-1;
     memset(&(((anode_t *)temp)->l), 0, sizeof(node_t));
     return ((anode_t *)temp);
}

anode_t * remove_anode_from_fq_list(anode_t *node)
{
     Lst *tempLst = NULL ;
     if(NULL == node || NULL == node->fql )
        return NULL ;

     tempLst=&(node->fql->lst);
     remove_node_from_lst(tempLst,(node_t*)&(node->l));
     return node ;
}

node_t * remove_and_return_first_node(Lst*l)
{
   node_t * ret= NULL ;
   if(NULL == l || 0 == l->c)
      return NULL  ;
   if(l->f == l-> l)
   {
       ret=l->f;
       l->f=l->l=NULL ;
       l->c=0;
   }
   else
   {
       ret=l->f;
       l->f=ret->n;
       l->f->p=NULL ;
      (l->c)--;
   }
   ret->n=ret->p=NULL ;
   return ret;
}

void insert_at_start_list(Lst * l , node_t * node)
{
   if(NULL == l || NULL == node )
     return  ;

   if(0 == l->c)
   {
       l->f=l->l=node;
       node->n=node->p=NULL ;
       (l->c)++;
   }
   else
   {
       node->n=l->f;
       node->p=NULL ;
       l->f->p=node;
       l->f=node;
       (l->c)++;
   }
}

void insert_at_end_list(Lst *l , node_t *node )
{
   if(NULL == l || NULL == node )
     return  ;
   if(0 == l->c)
   {
       l->f=l->l=node;
       node->n=node->p=NULL ;
       (l->c)++;
   }
   else
   {
       node->n=node->p=NULL ;
       node->p=l->l;
       l->l->n=node ;
       l->l=node;
       (l->c)++;
   }
}


void remove_node_from_lst(Lst * l , node_t * node)
{
   if(NULL == l || NULL == node)
   {
      return ;
   }

   if(NULL == node->p && NULL == node->n)
   {
       l->f=l->l=NULL ;
       l->c=0;
   }

   else if((NULL == (node->p)) && (NULL !=(node->n)))
   {
       l->f=node->n;
       l->f->p=NULL ;
       (l->c)--;
   }
   else if ((NULL == (node->n)) && (NULL != (node->p)))
   {
       l->l=node->p;
       (l->c)--;
       l->l->n=NULL ;
   }
   else
   {
       node->p->n=node->n;
       node->n->p=node->p;
       (l->c)--;
   }
   node->n=node->p=NULL ;
}



anode_t *lookup_node(Lst *l,int key, int jump)
{
     node_t * n= NULL ;
     anode_t *temp=NULL ;
     char gotNode=0;

     if(0 == l->c)
       return NULL ;

     n=l->f;

     while(NULL != n )
     {
         temp=(anode_t*)(n-jump);
         if(key == temp->key)
         {
            gotNode=1;
            break;
         }
         n=n->n;
     }
     if(gotNode)
       return temp ;
     else
       return NULL ;
}

void remove_node_from_hash_table(LFUCache *obj,anode_t * node )
{
   int idx = 0 ;
   if(NULL == obj || NULL == node )
      return  ;

   idx=(node->key)% HASH_BUCKET_SIZE;
   remove_node_from_lst(&(obj->ht[idx]),(node_t*)(&(node->h)));
   memset(&(node->h),0,sizeof(node_t));
}



LFUCache* lFUCacheCreate(int capacity)
{
    LFUCache * temp = NULL ;

    temp =malloc(sizeof(LFUCache));
    if(NULL == temp )
       return NULL ;
    memset(temp,0,sizeof(LFUCache));
    temp->c=capacity;
    temp->ht=malloc(sizeof(Lst)*HASH_BUCKET_SIZE);
    if(NULL == temp->ht)
    {
       free(temp);
       return  NULL ;
    }
    memset(temp->ht, 0,(sizeof(Lst)*HASH_BUCKET_SIZE));
    return  temp ;
}

int lFUCacheGet(LFUCache* obj, int key)
{
    anode_t * temp= NULL ;
    int idx= 0 ;
    int ret=-1;

    if(0 >= obj->count)
      return -1;	    

    idx=key%HASH_BUCKET_SIZE;
    temp=(anode_t*)lookup_node(&(obj->ht[idx]),key,0);
    if(NULL != temp )
    {
        increase_fq_of_node(obj,temp);
        ret=temp->data;
    }
    return ret;
}

void lFUCachePut(LFUCache* obj, int key, int value)
{
    anode_t * temp= NULL ;
    int idx= 0 ;

    if(0 >= obj->c)
      return ;	    

    idx=key%HASH_BUCKET_SIZE;

    temp=(anode_t*)lookup_node(&(obj->ht[idx]),key,0);
    if(NULL == temp )
    {
        if(obj->count < obj->c)
        {
            temp=malloc(sizeof(anode_t));
            if(NULL ==temp)
               return;
            memset(temp,0,sizeof(anode_t));
        }
        else
        {
            temp=remove_and_return_the_least_frequently_used_node(obj);
            remove_node_from_hash_table(obj,temp);
            memset(temp,0,sizeof(anode_t));
            (obj->count)--;
        }
        temp->data=value;
        temp->key=key ;
	temp->fq=1; 
        put_new_node_in_fq_list(obj,temp);
        insert_at_end_list(&(obj->ht[idx]),(node_t*)temp);
        (obj->count)++;
   }
   else
   {
        temp->data=value;
        increase_fq_of_node(obj,temp);
   }
}

void lFUCacheFree(LFUCache* obj)
{
    anode_t * temp ;
    Lst *templst= NULL ;
    int i=0;

    for (i=0;i<HASH_BUCKET_SIZE;i++)
    {
        templst=&(obj->ht[i]);
        while(0 != templst->c )
        {
             temp=(anode_t *)remove_and_return_first_node(templst);
             if(NULL !=  temp)
             {
                 remove_anode_from_fq_list(temp);
                 free(temp);
             }
        }
    }

}

/**
 * Your LFUCache struct will be instantiated and called as such:
 * LFUCache* obj = lFUCacheCreate(capacity);
 * int param_1 = lFUCacheGet(obj, key);

 * lFUCachePut(obj, key, value);

 * lFUCacheFree(obj);
*/

https://leetcode.com/problems/reverse-only-letters

#define IS_CHAR_LETTER(a) ((((a) >= 'A') && ((a)<='Z')) || (((a) <= 'z') && ((a)>='a')))

char * reverseOnlyLetters(char * s)
{
    char * p = NULL ;
    char * q= NULL ;
    char temp='\0';
    
    if(NULL == s)
        return NULL ;
    
    p=s;
    q=s+strlen(s)-1;

    while (p<q)
    {
        if ((IS_CHAR_LETTER(*p)) && ((IS_CHAR_LETTER(*q))))
        {
            temp=*p;
            *p=*q;
            *q=temp;
            p++;
            q--;
        }
        else 
        {    
           if (!(IS_CHAR_LETTER(*p)))
           {
              p++;
           }    
           if (!(IS_CHAR_LETTER(*q)))
           {
              q--;
            }
        }      
    }    
    return s;
}

https://leetcode.com/problems/top-k-frequent-elements/
class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        self.map1={}
        self.a=[]
        for i in nums:
            try:
                self.map1[i]=self.map1[i]+1
            except:
                self.map1[i]=1
            
        for i in range(10001):
             self.a.append([])
        for k1 in self.map1.keys():
             self.a[self.map1[k1]].append(k1)
         
        c=0
        self.a.reverse()
        ret=[]
        for i in self.a:
            ln1=len(i)
            c=c+ln1
            ret.extend(i)
            if len(ret) >= k :
               ret2=ret[0:k]
               break
           
        if len(ret2) == 0 :
            ret2=ret
        return ret2      

https://leetcode.com/problems/fibonacci-number
 int fib2(int * map,int n)
{
    if (-1 != map[n])
        return map[n];
    
    if(0 == n)
    {
        map[0]=0; 
        return  map[0];
    }  
    if (1 == n)
    {
        map[1]=1;
        return map[1];
    }    
    
    map[n-1]=fib2(map,n-1);
    map[n-2]=fib2(map,n-2);
    return map[n-1]+map[n-2];
}    


int fib(int n){

    int * map = NULL ;
    int i=0;
    
    map=malloc(sizeof(int)*40);
    memset(map,0,sizeof(int)*40);
    for(i=0;i<40;i++)
    {
        map[i]=-1;
    }    
    return fib2(map,n);
}

https://leetcode.com/problems/n-th-tribonacci-number/
int fib2(int * map,int n)
{
    if (-1 != map[n])
        return map[n];
    
    if(0 == n)
    {
        map[0]=0; 
        return  map[0];
    }  
    if (1 == n || 2== n)
    {
        map[1]=1;
        return map[1];
    }    
    
    map[n-1]=fib2(map,n-1);
    map[n-2]=fib2(map,n-2);
    map[n-3]=fib2(map,n-3);
    return map[n-1]+map[n-2]+map[n-3];
}    


int tribonacci(int n){

    int * map = NULL ;
    int i=0;
    
    map=malloc(sizeof(int)*40);
    memset(map,0,sizeof(int)*40);
    for(i=0;i<40;i++)
    {
        map[i]=-1;
    }    
    return fib2(map,n);
}

https://leetcode.com/problems/unique-paths
int ** alloc_matrix(int m , int n , int val )
{
    int **temp = NULL ;
    int i=0;
    int j=0;
    temp =(int **) malloc(sizeof(int *)*m);
    for(i=0;i<m;i++)
    {
        temp[i]=(int *)malloc(sizeof(int)*n);
        for(j=0;j<n;j++)
        {
            temp[i][j]=val;
        }    
    }    
    return temp ;
}    

void free_matrix(int **mt, int m , int n )
{
     int i=0;
    
     for(i=0;i<m;i++)
     {
         free(mt[i]);
     }    
     free(mt);
}

int uniquePaths(int m, int n){
    
    int **in= NULL ;
    int **out= NULL;
    int ret=0;
    int max_rows=m;
    int max_cols=n;
    
    in=alloc_matrix(m,n,0);
    out=alloc_matrix(m,n,0);
  
       int i=0;
   int j=0;
   out[max_rows-1][max_cols-1]=1;
   i=max_rows-1;
   for(j=max_cols-2;j>=0;j--)
   {
      if(in[i][j] == 1 )
        out[i][j]=0;
      else
        out[i][j]=out[i][j+1];
   }
   j=max_cols-1;
   for(i=max_rows-2;i>=0;i--)
   {
      if(in[i][j] == 1 )
        out[i][j]=0;
      else
        out[i][j]=out[i+1][j];
   }
   for(i=max_rows-2;i>=0;i--)
   {
      for(j=max_cols-2;j>=0;j--)
      {
         if(in[i][j] == 1)
           out[i][j]=0;
         else
           out[i][j]=out[i][j+1]+out[i+1][j];
      }
   }

   ret=out[0][0]; 
   free_matrix(in,m,n);
   free_matrix(out,m,n); 
   return ret;
}

https://leetcode.com/problems/contains-duplicate
class Solution(object):
    def containsDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        m={}
        for i in nums :
            try:
               m[i]
               return True 
            except:
               m[i]=i
               
        return False     
	
https://leetcode.com/problems/house-robber        
#include "limits.h"

int maxVal(int i , int j)
{
    if(i>j)
        return i;
    return j;
}    

int rob2(int *nums,int i , int max, int *map)
{
    if(i > (max-1))
        return 0;
     
    if(INT_MIN != map[i])
        return map[i]; 
    
    if(i == (max-1))
    {
        map[i]=nums[i];
        return map[i];
    }
    
    if(i==(max-2))
    {
        map[i]=maxVal(nums[i],rob2(nums,i+1,max,map));
        return map[i];
    }    
    
    map[i]=maxVal(nums[i]+rob2(nums,i+2,max,map),rob2(nums,i+1,max,map));
    return map[i];
}
int rob(int* nums, int numsSize)
{
    int *map= NULL ;
    int i=0;
    
    map=malloc(sizeof(int)*numsSize);
    if(NULL != map)
    {
        memset(map,0,sizeof(int)*numsSize);
    }    
    else 
       return  -1 ;   
    for (i=0;i<numsSize;i++)
    {
        map[i]=INT_MIN;
    }    

    rob2(nums,0,numsSize,map);
    return map[0];
}

https://leetcode.com/problems/house-robber-ii
#include "limits.h"

int maxVal(int i , int j)
{
    if(i>j)
        return i;
    return j;
}    

int rob2(int *nums,int i , int max, int *map)
{
    if(i > (max-1))
        return 0;
     
    if(INT_MIN != map[i])
        return map[i]; 
    
    if(i == (max-1))
    {
        map[i]=nums[i];
        return map[i];
    }
    
    if(i==(max-2))
    {
        map[i]=maxVal(nums[i],rob2(nums,i+1,max,map));
        return map[i];
    }    
    
    map[i]=maxVal(nums[i]+rob2(nums,i+2,max,map),rob2(nums,i+1,max,map));
    return map[i];
}
int rob3(int* nums, int numsSize)
{
    int *map= NULL ;
    int i=0;
    int ret=0;
    
    if(0 == numsSize)
      return  0;

    
    map=malloc(sizeof(int)*numsSize);
    if(NULL != map)
    {
        memset(map,0,sizeof(int)*numsSize);
    }    
    else 
       return  -1 ;   
    for (i=0;i<numsSize;i++)
    {
        map[i]=INT_MIN;
    }    

    rob2(nums,0,numsSize,map);
    ret=map[0];
    free(map);
    return ret;
}

int rob(int* nums, int numsSize)
{
  int max1=0;
  int max2=0;  
  if(0 == numsSize)
     return 0;

  if (1 == numsSize )
        return nums[0];

  if(2 == numsSize )
        return  maxVal(nums[0],nums[1]);

  max1=nums[0]+rob3(nums+2,numsSize-3);
  max2=rob3(nums+1,numsSize-1);
  return (maxVal(max1,max2));  
}

https://leetcode.com/problems/path-sum
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

void inorder_traversal(struct TreeNode* root , int *sum , int target , int *status  )
{
      if(NULL == root || 1 == *status)
          return ;
    
      if((NULL == root->left) && (NULL == root->right ))
      {
          *sum=*sum+root->val ;
          if(*sum == target)
          {
              *status=1;
              return  ; 
          }    
      }    
      else 
      {
          *sum=*sum+root->val ;
      }    
      inorder_traversal(root->left,sum,target,status);
      inorder_traversal(root->right,sum,target,status);
    
       *sum=*sum-(root->val);
       return ;
}   


bool hasPathSum(struct TreeNode* root, int targetSum)
{
    int status =0;
    int sum=0;
      
    inorder_traversal(root,&sum,targetSum,&status);
    if(1 == status)
        return true ;
    else 
        return false ;
}

https://leetcode.com/problems/maximum-depth-of-binary-tree
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */



void  inorder_traversal(struct TreeNode* root , int *path_len , int *max_path_len)
{
    int temp =0;
    if(NULL == root)
        return 
     printf("\n%d ",*path_len)   ;
    temp=*path_len;    
    *path_len=(temp+1);
    printf("\n %d %d ",  root->val , *path_len);   
     if((NULL == (root->left)) && (NULL ==(root->right)))
     {
         if(*path_len > *max_path_len)
         {
             *max_path_len=*path_len ;
         }    
     }
 
   // printf("\n%d ",*path_len)   ;
     inorder_traversal(root->left,path_len,max_path_len);
     inorder_traversal(root->right,path_len,max_path_len);
  
     temp=*path_len;
     *path_len=temp-1 ;
      return  ;
}    


int maxDepth(struct TreeNode* root){

    int path_len=0;
    int max=0;
    
    inorder_traversal(root,&path_len, &max);
    
    return  max ;
    
}

https://leetcode.com/problems/minimum-depth-of-binary-tree
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
#include "limits.h"
void  inorder_traversal(struct TreeNode* root , int *path_len , int *min_path_len)
{
    int temp =0;
    if(NULL == root)
        return 
     printf("\n%d ",*path_len)   ;
    temp=*path_len;    
    *path_len=(temp+1);
    printf("\n %d %d ",  root->val , *path_len);   
     if((NULL == (root->left)) && (NULL ==(root->right)))
     {
         if(*path_len < *min_path_len)
         {
             *min_path_len=*path_len ;
         }    
     }
 
   // printf("\n%d ",*path_len)   ;
     inorder_traversal(root->left,path_len,min_path_len);
     inorder_traversal(root->right,path_len,min_path_len);
  
     temp=*path_len;
     *path_len=temp-1 ;
      return  ;
}    


int minDepth(struct TreeNode* root){

    int path_len=0;
    int max=INT_MAX;
    
    inorder_traversal(root,&path_len, &max);
    
    if(INT_MAX ==  max)
        max=0;
    return  max ;
    
}

https://leetcode.com/problems/binary-tree-paths
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def create_str_from_lst(self,lst):
        str1=""
        for i in lst :
             str1=str1+str(i)+"->"
        str1=str1[:-2]        
        return  str1
    
    def binaryTreePaths2(self, root,out,lst):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        if None == root:
           return  
        
        lst.append(root.val)
        if None == root.left and None == root.right :
           str1=self.create_str_from_lst(lst)
           out.append(str1)
            
        self.binaryTreePaths2(root.left,out,lst)
        self.binaryTreePaths2(root.right,out,lst)
       
        del lst[-1]
        
    def  binaryTreePaths(self,root):
         out=[]
         lst=[]
         
         self.binaryTreePaths2(root,out,lst)
         return out 
