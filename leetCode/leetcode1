https://leetcode.com/problems/3sum
class Solution(object):
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        ret=[]
        if None == nums or len(nums) < 3 :
           return ret   
        nums.sort()
        idxL=len(nums)-1
        
        for i in range(len(nums)-3+1):
            j=i+1
            k=idxL
            diff=0-nums[i]
            while j < k :
                 if (nums[j]+nums[k]) > diff :
                    k=k-1
                 elif (nums[j]+nums[k]) < diff :
                    j=j+1
                 else :
                    if [nums[i],nums[j],nums[k]] not in ret :
                       ret.append([nums[i],nums[j],nums[k]])
                    j=j+1
                    k=k-1
        return ret

https://leetcode.com/problems/merge-strings-alternately/
char * mergeAlternately(char * word1, char * word2)
{
      char * ret= NULL ;
      int l1=0;
      int l2=0;
      int l3=0;
      int l4=0;
      int i=0;
      int j=0;
    
      if(NULL == word1 && NULL == word2)
      {
          ret=malloc(1);
          if(NULL == ret )
              return  ret ;
          ret[0]='\0' ;
          return ret;
      }    
      l1=strlen(word1);
      l2=strlen(word2);
    
      l3=l1+l2 ;
    

      ret=malloc(l3+1);
      if(NULL == ret)
         return ret;
    
      memset(ret,0,l3+1);
    
      if(0==l1 && 0 == l2)
      {
          ret[0]='\0';
          return ret;
      }    
    
      l4=l1>l2 ?l2:l1;
      while(i<l4)
      {
          ret[j]=word1[i];
          j++;
          ret[j]=word2[i];
          j++;
          i++;
      }    
      
      printf("\n%s",ret);
      if (l1 > l2)
          memcpy(&ret[j],&word1[i],strlen(&word1[i]));
      else if (l1 < l2)
          memcpy(&ret[j],&word2[i],strlen(&word2[i]));
      else 
          ret[j]='\0';
      
       return ret;

}

https://leetcode.com/problems/split-a-string-in-balanced-strings/
int balancedStringSplit(char * s)
{
      int c=0;
      int c1=0;
      int i=0;
      int len=0;
      char *p= s ;
      char *q = s;
    
      p=q=s;  
      while('\0' != *q)
      {
          if(*q=='R')
              c1=c1+1;
           else 
              c1=c1-1;  

          if(0 == c1)
          {
              c++; 
              p=q+1;
              q=p;              
          }
          else 
          {
              q=q+1;
          }    
          
      }    
      return c;

}

https://leetcode.com/problems/count-the-number-of-consistent-strings
#define MAX_SIZE 126
void update_map(char *in, char *map)
{
    int i =0;
    while('\0' != in[i])
    {
        if(0 == map[in[i]])
          map[in[i]]=1;
        i++;
    }    
} 

int countConsistentStrings(char * allowed, char ** words, int wordsSize)
{
    char map[MAX_SIZE]={0,};
    int i=0;
    char *temp=NULL ;
    int c=0;
    
    update_map(allowed, map);
    for(i=0;i<wordsSize;i++)
    {
        temp=words[i];
        if('\0' == *temp)
            continue;
        while('\0' != *temp)
        {
            if(0 == map[*temp])
                break;
            temp=temp+1;
        }    
        if('\0' == *temp)
            c++;
    }    

    return c; 
}

https://leetcode.com/problems/simplify-path

#define PATH_ENTRY_MAX_NUM 3000
#define PATH_LENGTH 3000

typedef struct stack 
{
    int c ;
    char *path_entry[PATH_ENTRY_MAX_NUM];
} stack ;

stack * init_stack()
{
    stack * temp = NULL ;
    
    temp = malloc(sizeof(stack));
    if(NULL == temp)
        return NULL ;
    memset(temp, 0, sizeof(stack));
    temp->c=-1;
    return temp;
}

void free_stack(stack *in)
{
    free(in);
}
           
void push_in_stack(stack *in , char *p)
{
    (in->c)++;
    in->path_entry[in->c]=p;
}
         
char * pop_from_stack(stack *in)
{
    char * ret= NULL ;
    if (0 > (in->c))
       return NULL ;
    
    ret=in->path_entry[in->c];
    (in->c)--;
    return ret;
}           
           
char * peep_from_stack(stack * in)           
{
    char * ret= NULL ;
    if (0 > (in->c))
       return NULL ;
    
    ret=in->path_entry[in->c];
    return ret;
}           

char * simplifyPath(char * path)
{
    stack  * s = NULL ;
    char * p = NULL ;
    char * q= NULL ;
    char end_reached=0;
    char *out = NULL ;
    int i=0;
    
    out=malloc(PATH_LENGTH);
    if(NULL == out)
        return out ;
    
    memset(out,0,PATH_LENGTH);
    
    s=init_stack();
    if(NULL == s)
        return NULL ;
    p=q=path;
    p++;
    q++;
    
    while('\0' != *q)
    {
        while('\0' != *p && '/' == *p)
        {
            p++;
        }
        if('\0' == *p)
           break ;
        q=p+1;
        while('\0' != *q && '/' !=*q)
        {
            q++;
        }
        if('\0' == *q)
        {    
            end_reached=1;
        }  
        *q='\0';
        if(strcmp(p,".")==0)
        {
            p=q+1;
            q=q+1;
        } 
        else if (strcmp("..",p)==0)
        {
            pop_from_stack(s);
            p=q+1;
            q=q+1;
        }
        else
        {    
           push_in_stack(s,p);
           p=q+1;
           q=q+1;
        }    
        if(end_reached)
            break ;
    }    
   
    out[0]='/';
    for (i=0;i<=(s->c);i++)
    {
        printf("\n%p",s->path_entry[i]);
        strcat(out,s->path_entry[i]);
        if(i != s->c)
           strcat(out,"/"); 
    }     
    
    free_stack(s); 
    return out ;     
}


https://leetcode.com/problems/counting-bits
class Solution(object):
    
    def count_1(self,inp):
        mask=1
        v=inp
        cnt=0
        while v > 0 :
              if ( v & mask ) == 1 :
                 cnt=cnt+1
              v=v>>1
        return cnt    
                   
                
    
    def countBits(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        lst=[0]
        for i in range(1,n+1):
            lst.append(self.count_1(i))
        return lst    
       
https://leetcode.com/problems/linked-list-components/
void update_map(char *in, int * a, int an)
{
    int i=0;
    
    for (i=0;i<an;i++)
    {
        in[a[i]]=1;
    }    
}   

#define MAP_SIZE  10005

int numComponents(struct ListNode* head, int* nums, int numsSize)
{
    int nc=0;
    int ret=0;
    char map[MAP_SIZE]={0,};
    
    struct ListNode *temp = NULL ;
    
    if(NULL == head)
        return 0;
    
    temp=head;
    update_map(map,nums,numsSize);
    while(NULL != temp )
    {
        if(1 == map[temp->val])
            nc++;
        else 
        {
            if (nc > 0)
            {
                ret++;
            }    
            nc=0; 
        }    
        temp=temp->next;
    }    
    if(nc>0)
       ret++; 
    return ret;
} 

//https://leetcode.com/problems/lfu-cache
#include "stdio.h"
#include <stdlib.h>
#include <string.h>
typedef struct node_s
{
   struct node_s *n;
   struct node_s *p;
}node_t ;

typedef struct Lst_s
{
   node_t * f;
   node_t * l ;
   int c ;
}Lst;
typedef struct fq_node_s
{
   node_t n;
   Lst lst ;
   int fq ;
}fq_node_t ;

typedef struct anode_s
{
    node_t h;
    node_t l;
    fq_node_t* fql;
    int key ;
    int data ;
    int fq;
}anode_t ;


#define DEBUG 1 



#define HASH_BUCKET_SIZE  100

typedef struct LFUCache
{
  int c;
  int count;
  Lst *ht;
  Lst fqL;
} LFUCache;

node_t * remove_and_return_first_node(Lst*l);
void insert_at_start_list(Lst * l , node_t * node);
void insert_at_end_list(Lst *l , node_t *node );
void remove_node_from_lst(Lst * l , node_t * node);
int  put_new_node_in_fq_list(LFUCache*cache, anode_t * node )
{
    Lst * temp = NULL ;
    fq_node_t * tempfqNode= NULL ;
    if(NULL == cache || NULL == node )
       return -1;

    node->fq=1;
    node->l.n=node->l.p=NULL ;
    temp=&(cache->fqL);
    if(0 == temp->c )
    {
        tempfqNode=(fq_node_t *)malloc(sizeof(fq_node_t ));
        if(NULL == tempfqNode )
        {
           return  -1 ;
        }
        memset(tempfqNode,0,sizeof(fq_node_t ));
        insert_at_start_list(temp,(node_t*)tempfqNode);
        tempfqNode->fq=1;
    }
    else
    {
        tempfqNode=(fq_node_t *)(cache->fqL.f);
    }
    insert_at_end_list(&(tempfqNode->lst),(node_t*)&(node->l));
    node->fql=tempfqNode;
    return 0;
}

void increase_fq_of_node(LFUCache*cache, anode_t * node )
{
    fq_node_t * fq_node= NULL ;
    fq_node_t * nfq_node=NULL ;
    node_t *temp= NULL ;
    int nfq=0;
    if(NULL == cache || NULL == node )
       return ;

    fq_node=node->fql;
    nfq=(node->fq)+1;

    nfq_node=(fq_node_t *)fq_node->n.n ;
    if(NULL == nfq_node )
    {
        nfq_node=(fq_node_t *) malloc(sizeof(fq_node_t ));
        if(NULL == nfq_node )
        {
            return  ;
        }
        memset(nfq_node,0,sizeof(fq_node_t ));
        insert_at_end_list(&(cache->fqL),(node_t*)&(nfq_node->n));
        nfq_node->fq=nfq;
    }
    remove_node_from_lst(&(node->fql->lst),(node_t*)&(node->l));
    insert_at_end_list(&(nfq_node->lst),(node_t*)&(node->l));
    node->fq=nfq;
    node->fql=nfq_node;
}

anode_t * remove_and_return_the_least_frequently_used_node(LFUCache*cache)
{
     node_t * temp ;
     Lst * tempfq= NULL ;
     fq_node_t*temp2= NULL ;  
     if(NULL == cache || 0 == cache->fqL.c )
        return NULL ;
     temp2=(fq_node_t*)(cache->fqL.f);
     if(NULL == temp2)
	return  NULL ;     
     while(NULL!= temp2 && 0 == temp2->lst.c )
     {
         temp2=(fq_node_t*)(temp2->n.n);	     
     }	     
     if(NULL == temp2)
       return NULL;
     temp=remove_and_return_first_node(&(temp2->lst));
     if(NULL ==  temp)
        return NULL ;
     temp=temp-1;
     memset(&(((anode_t *)temp)->l), 0, sizeof(node_t));
     return ((anode_t *)temp);
}

anode_t * remove_anode_from_fq_list(anode_t *node)
{
     Lst *tempLst = NULL ;
     if(NULL == node || NULL == node->fql )
        return NULL ;

     tempLst=&(node->fql->lst);
     remove_node_from_lst(tempLst,(node_t*)&(node->l));
     return node ;
}

node_t * remove_and_return_first_node(Lst*l)
{
   node_t * ret= NULL ;
   if(NULL == l || 0 == l->c)
      return NULL  ;
   if(l->f == l-> l)
   {
       ret=l->f;
       l->f=l->l=NULL ;
       l->c=0;
   }
   else
   {
       ret=l->f;
       l->f=ret->n;
       l->f->p=NULL ;
      (l->c)--;
   }
   ret->n=ret->p=NULL ;
   return ret;
}

void insert_at_start_list(Lst * l , node_t * node)
{
   if(NULL == l || NULL == node )
     return  ;

   if(0 == l->c)
   {
       l->f=l->l=node;
       node->n=node->p=NULL ;
       (l->c)++;
   }
   else
   {
       node->n=l->f;
       node->p=NULL ;
       l->f->p=node;
       l->f=node;
       (l->c)++;
   }
}

void insert_at_end_list(Lst *l , node_t *node )
{
   if(NULL == l || NULL == node )
     return  ;
   if(0 == l->c)
   {
       l->f=l->l=node;
       node->n=node->p=NULL ;
       (l->c)++;
   }
   else
   {
       node->n=node->p=NULL ;
       node->p=l->l;
       l->l->n=node ;
       l->l=node;
       (l->c)++;
   }
}


void remove_node_from_lst(Lst * l , node_t * node)
{
   if(NULL == l || NULL == node)
   {
      return ;
   }

   if(NULL == node->p && NULL == node->n)
   {
       l->f=l->l=NULL ;
       l->c=0;
   }

   else if((NULL == (node->p)) && (NULL !=(node->n)))
   {
       l->f=node->n;
       l->f->p=NULL ;
       (l->c)--;
   }
   else if ((NULL == (node->n)) && (NULL != (node->p)))
   {
       l->l=node->p;
       (l->c)--;
       l->l->n=NULL ;
   }
   else
   {
       node->p->n=node->n;
       node->n->p=node->p;
       (l->c)--;
   }
   node->n=node->p=NULL ;
}



anode_t *lookup_node(Lst *l,int key, int jump)
{
     node_t * n= NULL ;
     anode_t *temp=NULL ;
     char gotNode=0;

     if(0 == l->c)
       return NULL ;

     n=l->f;

     while(NULL != n )
     {
         temp=(anode_t*)(n-jump);
         if(key == temp->key)
         {
            gotNode=1;
            break;
         }
         n=n->n;
     }
     if(gotNode)
       return temp ;
     else
       return NULL ;
}

void remove_node_from_hash_table(LFUCache *obj,anode_t * node )
{
   int idx = 0 ;
   if(NULL == obj || NULL == node )
      return  ;

   idx=(node->key)% HASH_BUCKET_SIZE;
   remove_node_from_lst(&(obj->ht[idx]),(node_t*)(&(node->h)));
   memset(&(node->h),0,sizeof(node_t));
}



LFUCache* lFUCacheCreate(int capacity)
{
    LFUCache * temp = NULL ;

    temp =malloc(sizeof(LFUCache));
    if(NULL == temp )
       return NULL ;
    memset(temp,0,sizeof(LFUCache));
    temp->c=capacity;
    temp->ht=malloc(sizeof(Lst)*HASH_BUCKET_SIZE);
    if(NULL == temp->ht)
    {
       free(temp);
       return  NULL ;
    }
    memset(temp->ht, 0,(sizeof(Lst)*HASH_BUCKET_SIZE));
    return  temp ;
}

int lFUCacheGet(LFUCache* obj, int key)
{
    anode_t * temp= NULL ;
    int idx= 0 ;
    int ret=-1;

    if(0 >= obj->count)
      return -1;	    

    idx=key%HASH_BUCKET_SIZE;
    temp=(anode_t*)lookup_node(&(obj->ht[idx]),key,0);
    if(NULL != temp )
    {
        increase_fq_of_node(obj,temp);
        ret=temp->data;
    }
    return ret;
}

void lFUCachePut(LFUCache* obj, int key, int value)
{
    anode_t * temp= NULL ;
    int idx= 0 ;

    if(0 >= obj->c)
      return ;	    

    idx=key%HASH_BUCKET_SIZE;

    temp=(anode_t*)lookup_node(&(obj->ht[idx]),key,0);
    if(NULL == temp )
    {
        if(obj->count < obj->c)
        {
            temp=malloc(sizeof(anode_t));
            if(NULL ==temp)
               return;
            memset(temp,0,sizeof(anode_t));
        }
        else
        {
            temp=remove_and_return_the_least_frequently_used_node(obj);
            remove_node_from_hash_table(obj,temp);
            memset(temp,0,sizeof(anode_t));
            (obj->count)--;
        }
        temp->data=value;
        temp->key=key ;
	temp->fq=1; 
        put_new_node_in_fq_list(obj,temp);
        insert_at_end_list(&(obj->ht[idx]),(node_t*)temp);
        (obj->count)++;
   }
   else
   {
        temp->data=value;
        increase_fq_of_node(obj,temp);
   }
}

void lFUCacheFree(LFUCache* obj)
{
    anode_t * temp ;
    Lst *templst= NULL ;
    int i=0;

    for (i=0;i<HASH_BUCKET_SIZE;i++)
    {
        templst=&(obj->ht[i]);
        while(0 != templst->c )
        {
             temp=(anode_t *)remove_and_return_first_node(templst);
             if(NULL !=  temp)
             {
                 remove_anode_from_fq_list(temp);
                 free(temp);
             }
        }
    }

}

/**
 * Your LFUCache struct will be instantiated and called as such:
 * LFUCache* obj = lFUCacheCreate(capacity);
 * int param_1 = lFUCacheGet(obj, key);

 * lFUCachePut(obj, key, value);

 * lFUCacheFree(obj);
*/

https://leetcode.com/problems/reverse-only-letters

#define IS_CHAR_LETTER(a) ((((a) >= 'A') && ((a)<='Z')) || (((a) <= 'z') && ((a)>='a')))

char * reverseOnlyLetters(char * s)
{
    char * p = NULL ;
    char * q= NULL ;
    char temp='\0';
    
    if(NULL == s)
        return NULL ;
    
    p=s;
    q=s+strlen(s)-1;

    while (p<q)
    {
        if ((IS_CHAR_LETTER(*p)) && ((IS_CHAR_LETTER(*q))))
        {
            temp=*p;
            *p=*q;
            *q=temp;
            p++;
            q--;
        }
        else 
        {    
           if (!(IS_CHAR_LETTER(*p)))
           {
              p++;
           }    
           if (!(IS_CHAR_LETTER(*q)))
           {
              q--;
            }
        }      
    }    
    return s;
}

https://leetcode.com/problems/top-k-frequent-elements/
class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        self.map1={}
        self.a=[]
        for i in nums:
            try:
                self.map1[i]=self.map1[i]+1
            except:
                self.map1[i]=1
            
        for i in range(10001):
             self.a.append([])
        for k1 in self.map1.keys():
             self.a[self.map1[k1]].append(k1)
         
        c=0
        self.a.reverse()
        ret=[]
        for i in self.a:
            ln1=len(i)
            c=c+ln1
            ret.extend(i)
            if len(ret) >= k :
               ret2=ret[0:k]
               break
           
        if len(ret2) == 0 :
            ret2=ret
        return ret2      

https://leetcode.com/problems/fibonacci-number
 int fib2(int * map,int n)
{
    if (-1 != map[n])
        return map[n];
    
    if(0 == n)
    {
        map[0]=0; 
        return  map[0];
    }  
    if (1 == n)
    {
        map[1]=1;
        return map[1];
    }    
    
    map[n-1]=fib2(map,n-1);
    map[n-2]=fib2(map,n-2);
    return map[n-1]+map[n-2];
}    


int fib(int n){

    int * map = NULL ;
    int i=0;
    
    map=malloc(sizeof(int)*40);
    memset(map,0,sizeof(int)*40);
    for(i=0;i<40;i++)
    {
        map[i]=-1;
    }    
    return fib2(map,n);
}

https://leetcode.com/problems/n-th-tribonacci-number/
int fib2(int * map,int n)
{
    if (-1 != map[n])
        return map[n];
    
    if(0 == n)
    {
        map[0]=0; 
        return  map[0];
    }  
    if (1 == n || 2== n)
    {
        map[1]=1;
        return map[1];
    }    
    
    map[n-1]=fib2(map,n-1);
    map[n-2]=fib2(map,n-2);
    map[n-3]=fib2(map,n-3);
    return map[n-1]+map[n-2]+map[n-3];
}    


int tribonacci(int n){

    int * map = NULL ;
    int i=0;
    
    map=malloc(sizeof(int)*40);
    memset(map,0,sizeof(int)*40);
    for(i=0;i<40;i++)
    {
        map[i]=-1;
    }    
    return fib2(map,n);
}

https://leetcode.com/problems/unique-paths
int ** alloc_matrix(int m , int n , int val )
{
    int **temp = NULL ;
    int i=0;
    int j=0;
    temp =(int **) malloc(sizeof(int *)*m);
    for(i=0;i<m;i++)
    {
        temp[i]=(int *)malloc(sizeof(int)*n);
        for(j=0;j<n;j++)
        {
            temp[i][j]=val;
        }    
    }    
    return temp ;
}    

void free_matrix(int **mt, int m , int n )
{
     int i=0;
    
     for(i=0;i<m;i++)
     {
         free(mt[i]);
     }    
     free(mt);
}

int uniquePaths(int m, int n){
    
    int **in= NULL ;
    int **out= NULL;
    int ret=0;
    int max_rows=m;
    int max_cols=n;
    
    in=alloc_matrix(m,n,0);
    out=alloc_matrix(m,n,0);
  
       int i=0;
   int j=0;
   out[max_rows-1][max_cols-1]=1;
   i=max_rows-1;
   for(j=max_cols-2;j>=0;j--)
   {
      if(in[i][j] == 1 )
        out[i][j]=0;
      else
        out[i][j]=out[i][j+1];
   }
   j=max_cols-1;
   for(i=max_rows-2;i>=0;i--)
   {
      if(in[i][j] == 1 )
        out[i][j]=0;
      else
        out[i][j]=out[i+1][j];
   }
   for(i=max_rows-2;i>=0;i--)
   {
      for(j=max_cols-2;j>=0;j--)
      {
         if(in[i][j] == 1)
           out[i][j]=0;
         else
           out[i][j]=out[i][j+1]+out[i+1][j];
      }
   }

   ret=out[0][0]; 
   free_matrix(in,m,n);
   free_matrix(out,m,n); 
   return ret;
}

https://leetcode.com/problems/contains-duplicate
class Solution(object):
    def containsDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        m={}
        for i in nums :
            try:
               m[i]
               return True 
            except:
               m[i]=i
               
        return False     
	
https://leetcode.com/problems/house-robber        
#include "limits.h"

int maxVal(int i , int j)
{
    if(i>j)
        return i;
    return j;
}    

int rob2(int *nums,int i , int max, int *map)
{
    if(i > (max-1))
        return 0;
     
    if(INT_MIN != map[i])
        return map[i]; 
    
    if(i == (max-1))
    {
        map[i]=nums[i];
        return map[i];
    }
    
    if(i==(max-2))
    {
        map[i]=maxVal(nums[i],rob2(nums,i+1,max,map));
        return map[i];
    }    
    
    map[i]=maxVal(nums[i]+rob2(nums,i+2,max,map),rob2(nums,i+1,max,map));
    return map[i];
}
int rob(int* nums, int numsSize)
{
    int *map= NULL ;
    int i=0;
    
    map=malloc(sizeof(int)*numsSize);
    if(NULL != map)
    {
        memset(map,0,sizeof(int)*numsSize);
    }    
    else 
       return  -1 ;   
    for (i=0;i<numsSize;i++)
    {
        map[i]=INT_MIN;
    }    

    rob2(nums,0,numsSize,map);
    return map[0];
}

https://leetcode.com/problems/house-robber-ii
#include "limits.h"

int maxVal(int i , int j)
{
    if(i>j)
        return i;
    return j;
}    

int rob2(int *nums,int i , int max, int *map)
{
    if(i > (max-1))
        return 0;
     
    if(INT_MIN != map[i])
        return map[i]; 
    
    if(i == (max-1))
    {
        map[i]=nums[i];
        return map[i];
    }
    
    if(i==(max-2))
    {
        map[i]=maxVal(nums[i],rob2(nums,i+1,max,map));
        return map[i];
    }    
    
    map[i]=maxVal(nums[i]+rob2(nums,i+2,max,map),rob2(nums,i+1,max,map));
    return map[i];
}
int rob3(int* nums, int numsSize)
{
    int *map= NULL ;
    int i=0;
    int ret=0;
    
    if(0 == numsSize)
      return  0;

    
    map=malloc(sizeof(int)*numsSize);
    if(NULL != map)
    {
        memset(map,0,sizeof(int)*numsSize);
    }    
    else 
       return  -1 ;   
    for (i=0;i<numsSize;i++)
    {
        map[i]=INT_MIN;
    }    

    rob2(nums,0,numsSize,map);
    ret=map[0];
    free(map);
    return ret;
}

int rob(int* nums, int numsSize)
{
  int max1=0;
  int max2=0;  
  if(0 == numsSize)
     return 0;

  if (1 == numsSize )
        return nums[0];

  if(2 == numsSize )
        return  maxVal(nums[0],nums[1]);

  max1=nums[0]+rob3(nums+2,numsSize-3);
  max2=rob3(nums+1,numsSize-1);
  return (maxVal(max1,max2));  
}

https://leetcode.com/problems/path-sum
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

void inorder_traversal(struct TreeNode* root , int *sum , int target , int *status  )
{
      if(NULL == root || 1 == *status)
          return ;
    
      if((NULL == root->left) && (NULL == root->right ))
      {
          *sum=*sum+root->val ;
          if(*sum == target)
          {
              *status=1;
              return  ; 
          }    
      }    
      else 
      {
          *sum=*sum+root->val ;
      }    
      inorder_traversal(root->left,sum,target,status);
      inorder_traversal(root->right,sum,target,status);
    
       *sum=*sum-(root->val);
       return ;
}   


bool hasPathSum(struct TreeNode* root, int targetSum)
{
    int status =0;
    int sum=0;
      
    inorder_traversal(root,&sum,targetSum,&status);
    if(1 == status)
        return true ;
    else 
        return false ;
}

https://leetcode.com/problems/maximum-depth-of-binary-tree
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */



void  inorder_traversal(struct TreeNode* root , int *path_len , int *max_path_len)
{
    int temp =0;
    if(NULL == root)
        return 
     printf("\n%d ",*path_len)   ;
    temp=*path_len;    
    *path_len=(temp+1);
    printf("\n %d %d ",  root->val , *path_len);   
     if((NULL == (root->left)) && (NULL ==(root->right)))
     {
         if(*path_len > *max_path_len)
         {
             *max_path_len=*path_len ;
         }    
     }
 
   // printf("\n%d ",*path_len)   ;
     inorder_traversal(root->left,path_len,max_path_len);
     inorder_traversal(root->right,path_len,max_path_len);
  
     temp=*path_len;
     *path_len=temp-1 ;
      return  ;
}    


int maxDepth(struct TreeNode* root){

    int path_len=0;
    int max=0;
    
    inorder_traversal(root,&path_len, &max);
    
    return  max ;
    
}

https://leetcode.com/problems/minimum-depth-of-binary-tree
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
#include "limits.h"
void  inorder_traversal(struct TreeNode* root , int *path_len , int *min_path_len)
{
    int temp =0;
    if(NULL == root)
        return 
     printf("\n%d ",*path_len)   ;
    temp=*path_len;    
    *path_len=(temp+1);
    printf("\n %d %d ",  root->val , *path_len);   
     if((NULL == (root->left)) && (NULL ==(root->right)))
     {
         if(*path_len < *min_path_len)
         {
             *min_path_len=*path_len ;
         }    
     }
 
   // printf("\n%d ",*path_len)   ;
     inorder_traversal(root->left,path_len,min_path_len);
     inorder_traversal(root->right,path_len,min_path_len);
  
     temp=*path_len;
     *path_len=temp-1 ;
      return  ;
}    


int minDepth(struct TreeNode* root){

    int path_len=0;
    int max=INT_MAX;
    
    inorder_traversal(root,&path_len, &max);
    
    if(INT_MAX ==  max)
        max=0;
    return  max ;
    
}

https://leetcode.com/problems/binary-tree-paths
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def create_str_from_lst(self,lst):
        str1=""
        for i in lst :
             str1=str1+str(i)+"->"
        str1=str1[:-2]        
        return  str1
    
    def binaryTreePaths2(self, root,out,lst):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        if None == root:
           return  
        
        lst.append(root.val)
        if None == root.left and None == root.right :
           str1=self.create_str_from_lst(lst)
           out.append(str1)
            
        self.binaryTreePaths2(root.left,out,lst)
        self.binaryTreePaths2(root.right,out,lst)
       
        del lst[-1]
        
    def  binaryTreePaths(self,root):
         out=[]
         lst=[]
         
         self.binaryTreePaths2(root,out,lst)
         return out 
