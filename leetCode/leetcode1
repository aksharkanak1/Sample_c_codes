https://leetcode.com/problems/3sum
class Solution(object):
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        ret=[]
        if None == nums or len(nums) < 3 :
           return ret   
        nums.sort()
        idxL=len(nums)-1
        
        for i in range(len(nums)-3+1):
            j=i+1
            k=idxL
            diff=0-nums[i]
            while j < k :
                 if (nums[j]+nums[k]) > diff :
                    k=k-1
                 elif (nums[j]+nums[k]) < diff :
                    j=j+1
                 else :
                    if [nums[i],nums[j],nums[k]] not in ret :
                       ret.append([nums[i],nums[j],nums[k]])
                    j=j+1
                    k=k-1
        return ret

https://leetcode.com/problems/merge-strings-alternately/
char * mergeAlternately(char * word1, char * word2)
{
      char * ret= NULL ;
      int l1=0;
      int l2=0;
      int l3=0;
      int l4=0;
      int i=0;
      int j=0;
    
      if(NULL == word1 && NULL == word2)
      {
          ret=malloc(1);
          if(NULL == ret )
              return  ret ;
          ret[0]='\0' ;
          return ret;
      }    
      l1=strlen(word1);
      l2=strlen(word2);
    
      l3=l1+l2 ;
    

      ret=malloc(l3+1);
      if(NULL == ret)
         return ret;
    
      memset(ret,0,l3+1);
    
      if(0==l1 && 0 == l2)
      {
          ret[0]='\0';
          return ret;
      }    
    
      l4=l1>l2 ?l2:l1;
      while(i<l4)
      {
          ret[j]=word1[i];
          j++;
          ret[j]=word2[i];
          j++;
          i++;
      }    
      
      printf("\n%s",ret);
      if (l1 > l2)
          memcpy(&ret[j],&word1[i],strlen(&word1[i]));
      else if (l1 < l2)
          memcpy(&ret[j],&word2[i],strlen(&word2[i]));
      else 
          ret[j]='\0';
      
       return ret;

}

https://leetcode.com/problems/split-a-string-in-balanced-strings/
int balancedStringSplit(char * s)
{
      int c=0;
      int c1=0;
      int i=0;
      int len=0;
      char *p= s ;
      char *q = s;
    
      p=q=s;  
      while('\0' != *q)
      {
          if(*q=='R')
              c1=c1+1;
           else 
              c1=c1-1;  

          if(0 == c1)
          {
              c++; 
              p=q+1;
              q=p;              
          }
          else 
          {
              q=q+1;
          }    
          
      }    
      return c;

}

https://leetcode.com/problems/count-the-number-of-consistent-strings
#define MAX_SIZE 126
void update_map(char *in, char *map)
{
    int i =0;
    while('\0' != in[i])
    {
        if(0 == map[in[i]])
          map[in[i]]=1;
        i++;
    }    
} 

int countConsistentStrings(char * allowed, char ** words, int wordsSize)
{
    char map[MAX_SIZE]={0,};
    int i=0;
    char *temp=NULL ;
    int c=0;
    
    update_map(allowed, map);
    for(i=0;i<wordsSize;i++)
    {
        temp=words[i];
        if('\0' == *temp)
            continue;
        while('\0' != *temp)
        {
            if(0 == map[*temp])
                break;
            temp=temp+1;
        }    
        if('\0' == *temp)
            c++;
    }    

    return c; 
}

https://leetcode.com/problems/simplify-path

#define PATH_ENTRY_MAX_NUM 3000
#define PATH_LENGTH 3000

typedef struct stack 
{
    int c ;
    char *path_entry[PATH_ENTRY_MAX_NUM];
} stack ;

stack * init_stack()
{
    stack * temp = NULL ;
    
    temp = malloc(sizeof(stack));
    if(NULL == temp)
        return NULL ;
    memset(temp, 0, sizeof(stack));
    temp->c=-1;
    return temp;
}

void free_stack(stack *in)
{
    free(in);
}
           
void push_in_stack(stack *in , char *p)
{
    (in->c)++;
    in->path_entry[in->c]=p;
}
         
char * pop_from_stack(stack *in)
{
    char * ret= NULL ;
    if (0 > (in->c))
       return NULL ;
    
    ret=in->path_entry[in->c];
    (in->c)--;
    return ret;
}           
           
char * peep_from_stack(stack * in)           
{
    char * ret= NULL ;
    if (0 > (in->c))
       return NULL ;
    
    ret=in->path_entry[in->c];
    return ret;
}           

char * simplifyPath(char * path)
{
    stack  * s = NULL ;
    char * p = NULL ;
    char * q= NULL ;
    char end_reached=0;
    char *out = NULL ;
    int i=0;
    
    out=malloc(PATH_LENGTH);
    if(NULL == out)
        return out ;
    
    memset(out,0,PATH_LENGTH);
    
    s=init_stack();
    if(NULL == s)
        return NULL ;
    p=q=path;
    p++;
    q++;
    
    while('\0' != *q)
    {
        while('\0' != *p && '/' == *p)
        {
            p++;
        }
        if('\0' == *p)
           break ;
        q=p+1;
        while('\0' != *q && '/' !=*q)
        {
            q++;
        }
        if('\0' == *q)
        {    
            end_reached=1;
        }  
        *q='\0';
        if(strcmp(p,".")==0)
        {
            p=q+1;
            q=q+1;
        } 
        else if (strcmp("..",p)==0)
        {
            pop_from_stack(s);
            p=q+1;
            q=q+1;
        }
        else
        {    
           push_in_stack(s,p);
           p=q+1;
           q=q+1;
        }    
        if(end_reached)
            break ;
    }    
   
    out[0]='/';
    for (i=0;i<=(s->c);i++)
    {
        printf("\n%p",s->path_entry[i]);
        strcat(out,s->path_entry[i]);
        if(i != s->c)
           strcat(out,"/"); 
    }     
    
    free_stack(s); 
    return out ;     
}


https://leetcode.com/problems/counting-bits
class Solution(object):
    
    def count_1(self,inp):
        mask=1
        v=inp
        cnt=0
        while v > 0 :
              if ( v & mask ) == 1 :
                 cnt=cnt+1
              v=v>>1
        return cnt    
                   
                
    
    def countBits(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        lst=[0]
        for i in range(1,n+1):
            lst.append(self.count_1(i))
        return lst    
       
https://leetcode.com/problems/linked-list-components/
void update_map(char *in, int * a, int an)
{
    int i=0;
    
    for (i=0;i<an;i++)
    {
        in[a[i]]=1;
    }    
}   

#define MAP_SIZE  10005

int numComponents(struct ListNode* head, int* nums, int numsSize)
{
    int nc=0;
    int ret=0;
    char map[MAP_SIZE]={0,};
    
    struct ListNode *temp = NULL ;
    
    if(NULL == head)
        return 0;
    
    temp=head;
    update_map(map,nums,numsSize);
    while(NULL != temp )
    {
        if(1 == map[temp->val])
            nc++;
        else 
        {
            if (nc > 0)
            {
                ret++;
            }    
            nc=0; 
        }    
        temp=temp->next;
    }    
    if(nc>0)
       ret++; 
    return ret;
} 


